-- phpMyAdmin SQL Dump
-- version 4.0.10deb1
-- http://www.phpmyadmin.net
--
-- Host: localhost
-- Generation Time: Jun 02, 2015 at 02:28 PM
-- Server version: 5.5.43-0ubuntu0.14.04.1
-- PHP Version: 5.5.9-1ubuntu4.9

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- Database: `acm`
--

-- --------------------------------------------------------

--
-- Table structure for table `cource`
--

CREATE TABLE IF NOT EXISTS `cource` (
  `id` int(11) NOT NULL,
  `theory` text NOT NULL,
  `example` text NOT NULL,
  UNIQUE KEY `id_3` (`id`),
  KEY `id` (`id`),
  KEY `id_2` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `cource`
--

INSERT INTO `cource` (`id`, `theory`, `example`) VALUES
(1, '<a href="http://acmp.ru/index.asp?main=task&id_task=337"><h2>Умова</h2></a>\n\n<h2>Розвязок</h2>\n\n<p>В даній задачі нам просто потрібно зробити всі вказані інверсії у вказаному порядку.</p>\n<p>Тобто, спочатку всі лампочки вимкнені.Під час інверсії ми вмикаємо лампочку, якщо вона вимкнена, та вимикаємо - якщо увімкнена.</p>\n<p>Зробивши вказану процедуру для всіх інверсій ми маємо фінальний стан лампочок. Все що нам залишається зробити, це підрахувати к-сть увімкнений лампочок.</p>\n\n<h2>Повний розбір</h2>\n<p>Для початку створимо масив лампочок та інверсій:</p>\n<pre>\nint N, K;  // к-сть лампочок та інверсій\nbool* lightbulbs = new bool[N];\nint* inversion = new int[K];\nfor (int i = 0; i < K; i++)\n	cin >> inversion[i];\n// позначити всі лампочки як вимкнені\nfor (int i = 0; i < N; i++)\n	lightbulbs[i] = false;\n</pre>\n<p>Як бачимо масив лампочок - це масив типу bool, де індекс це номер лампочки, а булеве значення це стан (true - лампочка увімкнена, false - вимкнена)</p>\n<p>Тепер необхідно реалізувати інверсію лампочок. Для цього змінюватимо значення, вказаних в інверсії лампочок, на протилежні (true на false, а false на true):</p>\n<pre>\nfor (int i = 0; i < K; i++)\n{\n	int current_num = inversion[i]; // поточна лампочка для інверсії\n	while (current_num <= N) // поки не всі можливі лампочки інверсовані\n	{\n		if (lightbulbs[current_num-1])  // якщо лампочка увімкнена\n			lightbulbs[current_num-1] = false;  // то вимкнути\n		else lightbulbs[current_num-1] = true;  // інакше увімункти\n			current_num += inversion[i]; // перейти до наступної лампочки\n	}\n}\n</pre>\n<p>Все що нам залишилося зробити, це підрахувати к-сть увімкнених лампочок:</p>\n<pre>\nint result = 0; // к-сть увімкнених лампочок\nfor (int i = 0; i < N; i++)\n	if (lightbulbs[i]) // якщо лампочка увімкнена\n		result++; // збільшити результат на 1\n</pre>\n<p>Відповідь знайдена.</p>\n', '#include <iostream>\n\nusing namespace std;\n\nint N, K, result = 0;  // к-сть лампочок, інверсій та кінцева відповідь\nbool *lightbulbs; // масив лампочок\nint *inversion; // масив інверсій\n\n// вивід проміжного стану\nvoid output()\n{\n	for (int i = 0; i < N; i++)\n	{\n		cout << i + 1 << ": "; // номер поточної лампочки\n		if (lightbulbs[i]) // якщо лампока увімкнена\n			cout << "on ";\n		else\n			cout << "off ";\n	}\n	cout << endl;\n}\n\n// зробити інверсії лампочок\nvoid inverse()\n{\n	for (int i = 0; i < K; i++)\n	{\n		cout << i + 1 << " inversion: " << endl;\n		int current_num = inversion[i]; // поточна лампочка для інверсії\n		while (current_num <= N) // поки не всі можливі лампочки інверсовані\n		{\n			if (lightbulbs[current_num-1])  // якщо лампочка увімкнена\n				lightbulbs[current_num-1] = false;  // то вимкнути\n			else lightbulbs[current_num-1] = true;  // інакше увімункти\n				current_num += inversion[i]; // перейти до наступної лампочки\n		}\n		output();  // вивести проміжний стан\n	}\n	for (int i = 0; i < N; i++)\n		if (lightbulbs[i]) // якщо лампочка увімкнена\n			result++; // збільшити результат на 1\n}\n\nint main()\n{\n	cout << "Lightbulb inversions." << endl;\n	cout << "Enter number of lightbulbs and number of inversions: ";\n	cin >> N >> K;\n	lightbulbs = new bool[N];\n	inversion = new int[K];\n	cout << "Enter all inversions: " << endl;\n	for (int i = 0; i < K; i++)\n	{\n		cout << i + 1 << ": ";\n		cin >> inversion[i];\n	}\n	// позначити всі лампочки як вимкнені\n	for (int i = 0; i < N; i++)\n		lightbulbs[i] = false;\n	inverse();\n	cout << result << " lightbulbs will be on" << endl;\n	delete lightbulbs;\n	delete inversion;\n	system("pause");\n}'),
(2, '<a href="http://acmp.ru/index.asp?main=task&id_task=656">Умова</a>\n\n<h2>Розв''язок</h2>\n<p>З умови випливає, що вхідний граф - дерево, адже не районні центри можуть бути з''єднані лише через районні центри.</p>\n<p>Відповідь шукатимемо шляхом відкидання "непотрібних" доріг. Такими дорогами є ребра дерева, що з''єднують термінальні вершини.</p>\n<p>Тобто, на кожній ітерації ми відкидатимо одне ребро. Яке саме визначаємо так:</p>\n<p>- Дане ребро з''єднує термінальну вершину.</p>\n<p>- Дане ребро є найдорожчим з усіх, що з''єднують термінальні вершини.</p>\n<p>Відкидатимо дороги, доки не залишиться вказана к-сть доріг.</p>\n\n<h2>Повний розбір</h2>\n<p>Зберегіти граф будемо у вигляді масиву ребер. Для цього створемо структуру для ребра:</p>\n<pre>\nstruct edge\n{\n	// початок ребра\n	int start;\n	// кінець ребра\n	int end;\n	// вага ребра\n	int veight;\n	// номер ребра\n	int number;\n};\n</pre>\n<p>При введені ребер графу, також будемо рахувати степені вершин, що знадобиться для визначення термінальних вершин:</p>\n<pre>\n// к-сть міст, доріг всього та доріг для покупки\nint n,m,k;\n// масив ребер\nedge* Edges = new edge[m];\n// масив з к-стю інцидентних ребер до кожної вершини\nint* vertexes = new int[n];\n// позначити степені всіх вершин 0 для подальшого їх обрахунку\nfor (int i = 0; i < n; i++)\n	vertexes[i] = 0;\ncout << "Input roads and their price:" << endl;\nfor (int i = 0; i < m; i++)\n{\n	cout << i + 1 << ": ";\n	cin >> Edges[i].start >> Edges[i].end >> Edges[i].veight;\n	// зберегти початковий номер ребра\n	Edges[i].number = i + 1;\n	// збільшити к-сть інцедентних ребер на 1 для початкової та кінцевої вершини\n	vertexes[Edges[i].start - 1] ++;\n	vertexes[Edges[i].end - 1] ++;\n}\n</pre>\n<p>Так як нам необхідно витратити якнайменше коштів, то відсортуємо масив ребер за вартістю. Для цого використаємо стандартну ф-цію qsort:</p>\n<p>qsort(Edges, m, sizeof(edge), comp);</p>\n<p>comp - це функція порівняння, в які нам необхідно вказати як нам порівнювати ребра:</p>\n<pre>\n// елементи, що порівнюються\nint comp(const void *i, const void *j)\n{\n	edge* a = (edge*)i;\n	edge* b = (edge*)j;\n	// порівнювати за вагою ребра\n	return (a->veight - b->veight); \n}\n</pre>\n<p>Тепер просто на кожному кроці із всіх ребер, що з''єднують термінальні вершини, видалятимемо найдорожчі доти, доки не залишиться вказана к-сть доріг:</p>\n<pre>\nfor (int i = 0; i < (m-k); i++)\n{\n	// починати з ребра найбільшої ваги\n	int j = m-1;\n	while (j >= 0)\n	{\n		// якщо ребро ще не відкинуте і одній з вершин інцидентне тільки це ребро\n		if (Edges[j].number!= 0 && (vertexes[Edges[j].start - 1] == 1 || vertexes[Edges[j].end - 1] == 1))\n		{\n			cout << "We shouldn''t buy road from " << Edges[j].start << " to " << Edges[j].end << "(delete this road from graph)" << endl;\n			// зменшити к-сть інцедентних ребер на 1 для початкової та кінцевої вершини ребра\n			vertexes[Edges[j].start-1] --;\n			vertexes[Edges[j].end-1] --;\n			// позначити поточне ребро як видалене\n			Edges[j].number = 0;\n			break;\n		}\n		j--;\n	}\n}\n</pre>\n<p>Ребра, що залишилися і є дорогами, які необхідно придбати:</p>\n<pre>\n// вивести ребра, що залишилися\ncout << "So, you need to buy this roads:" << endl;\nfor (int i = 0; i < m; i++)\n{\n	if (Edges[i].number != 0)\n		cout << Edges[i].number << ": " << Edges[i].start << " " << Edges[i].end << endl;\n}\n</pre>', '#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nstruct edge\n{\n	int start; // початок ребра\n	int end; // кінець ребра\n	int veight; // вага ребра\n	int number; // номер ребра\n};\n\nint n,m,k; // к-сть міст, доріг всього та доріг для покупки\nedge * Edges; // масив ребер\nint* vertexes; // масив з к-стю інцидентних ребер до кожної вершини\n\nint comp(const void *i, const void *j) // елементи, що порівнюються\n{\n	edge* a = (edge*)i;\n	edge* b = (edge*)j;\n	return (a->veight - b->veight);  // порівнювати за вагою ребра\n}\n\n// вивід проміжних результатів\nvoid output()\n{\n	cout << "--------------------------" << endl;\n	for (int i = 0; i < n; i++)\n	{\n		cout << i + 1 << ": ";\n		if (vertexes[i] == 0)\n			cout << "not connected";\n		else\n		{\n			for (int j = 0; j < m; j++)\n			{\n				if (Edges[j].number != 0 && (Edges[j].end == (i + 1) || Edges[j].start == (i + 1)))\n				{\n					if (Edges[j].end == (i + 1))\n						cout << Edges[j].start << " (" << Edges[j].veight <<") ";\n					else\n						cout << Edges[j].end << " (" << Edges[j].veight << ") ";\n				}\n			}\n		}\n		cout << endl;\n	}\n	cout << "--------------------------" << endl;\n}\n\n// прочитати файл\nvoid read()\n{\n	ifstream input("input.txt");\n	input >> n >> m >> k;\n	cout << "Yoy need to buy " << k << " roads" << endl;\n	Edges = new edge[m];\n	vertexes = new int[n];\n	// позначити степені всіх вершин 0 для подальшого їх обрахунку\n	for (int i = 0; i < n; i++)\n		vertexes[i] = 0;\n	cout << "Roads and their price:" << endl;\n	for (int i = 0; i < m; i++)\n	{\n		cout << i + 1 << ": ";\n		input >> Edges[i].start >> Edges[i].end >> Edges[i].veight;\n		cout << Edges[i].start << " " << Edges[i].end << " " << Edges[i].veight << endl;\n		Edges[i].number = i + 1; // зберегти початковий номер ребра\n		// збільшити к-сть інцедентних ребер на 1 для початкової та кінцевої вершини\n		vertexes[Edges[i].start - 1] ++;\n		vertexes[Edges[i].end - 1] ++;\n	}\n	qsort(Edges, m, sizeof(edge), comp);\n	input.close();\n}\n\nvoid input()\n{\n	cout << "Input number of towns, all roads and amount of roads to buy: ";\n	cin >> n >> m >> k;\n	Edges = new edge[m];\n	vertexes = new int[n];\n	// позначити степені всіх вершин 0 для подальшого їх обрахунку\n	for (int i = 0; i < n; i++)\n		vertexes[i] = 0;\n	cout << "Input roads and their price:" << endl;\n	for (int i = 0; i < m; i++)\n	{\n		cout << i + 1 << ": ";\n		cin >> Edges[i].start >> Edges[i].end >> Edges[i].veight;\n		Edges[i].number = i + 1; // зберегти початковий номер ребра\n		// збільшити к-сть інцедентних ребер на 1 для початкової та кінцевої вершини\n		vertexes[Edges[i].start - 1] ++;\n		vertexes[Edges[i].end - 1] ++;\n	}\n	qsort(Edges, m, sizeof(edge), comp); // сортування ребер за їх вагою\n}\n\nvoid Solution()\n{\n	//Заданий граф - дерево, тому для знаходження мінімального варіанту,\n	//відкидатимо термінальні вершини, до яких відстань найбільша\n	for (int i = 0; i < (m-k); i++)\n	{\n		getchar();\n		int j = m-1; // починати з ребра найбільшої ваги\n		while (j >= 0)\n		{\n			// якщо ребро ще не відкинуте і одній з вершин інцидентне тільки це ребро\n			if (Edges[j].number!= 0 && (vertexes[Edges[j].start - 1] == 1 || vertexes[Edges[j].end - 1] == 1))\n			{\n				cout << "We shouldn''t buy road from " << Edges[j].start << " to " << Edges[j].end << "(delete this road from graph)" << endl;\n				// зменшити к-сть інцедентних ребер на 1 для початкової та кінцевої вершини ребра\n				vertexes[Edges[j].start-1] --;\n				vertexes[Edges[j].end-1] --;\n				Edges[j].number = 0; // позначити поточне ребро як видалене\n				break;\n			}\n			j--;\n		}\n		output();\n	}\n	delete vertexes;\n}\n\nint main()\n{\n	cout << "Input graph is a tree. So to find out wich road we should buy" << endl;\n	cout << "we need to delete roads wich conect terminal vertex \\n(because we need to get a tree too) and are most expensive." << endl;\n	cout << "We will do it while left only entered amount of roads wich we can buy" << endl;\n	cout << "Read graph from example from file?[y/n]" << endl;\n	if (getchar() == ''n'') // якщо користувач вирішив ввести граф вручну\n		input();\n	else\n		read();\n	cout << "Input tree:" << endl;\n	cout << "List of vertexes. In scobes you can see price of this road" << endl;\n	output();\n	cout << "To go to the next step just press any key" << endl;\n	Solution();\n	// вивести ребра, що залишилися\n	cout << "So, you need to buy this roads:" << endl;\n	for (int i = 0; i < m; i++)\n	{\n		if (Edges[i].number != 0)\n			cout << Edges[i].number << ": " << Edges[i].start << " " << Edges[i].end << endl;\n	}\n	delete Edges;\n	system("pause");\n}'),
(3, '<a href="http://acmp.ru/index.asp?main=task&id_task=204"><h2>Умова</h2></a>\n\n<h2>Розвязок</h2>\n<p>Спочатку найменшою можливою довжиною рядка вважатимемо 1 (ми будемо збільшувати цю величену, доки не переконаємось, що такий рядок можливий).</p>\n<p>Тепер потрібно переконатись чи справді можливий рядок з такою довжиною.</p>\n<p>Початковим символом шуканого рядка вважатимемо перший символ вхідного рядка (так як у вихідний рядок кожен символ повинен увійти хоч раз, то ми не пропускаємо ні один з варіантів).</p>\n<p>Тепер будемо рухатись по символам вхідного рядка. Поточним символом є символ рядка з індексом найменшої можливої довжини вихідного рядка.</p>\n<p>Далі необхідно перевірити чи дорівнює поточний символ початковому.</p>\n<p>Якщо дорівнює, то необхідно перевірити на рівність решти символів, вважаючи, що починаючи з поточного символу вихідний рядок повторюється. Якщо всі символи співпали, то ми знайшли найменшу можливу довжину вихідного рядка.</p>\n<p>Якщо не дорівнює поточним символом вважаємо наступний, та збільшуємо найменшу мажливу довжину вихідного рядка на 1. Повторюємо вищевказану процедуру знову.</p>\n<p>В кінці роботи даного алгоритму ми матимемо найменшу можливу довжину.</p>\n<p></p>\n<h2>Повний розбір</h2>\n<p>Для того, щоб гарантовано знайти найменшу можливу довжину, ми перевірятимемо можливість існування рядка з певною довжиною. Почнемо ми з найменшого - рядка довжиною 1 та будемо збільшувати це значення на 1, доки не переконаємось, що такий рядок можливий.</p>\n<p>Зрозуміло, що в найгіршому випадку найменша можлива довжина дорівнюватиме довжині вхідного рядку. Тому у випадку, якщо жоден з рядків, довжиною меншою, не пройшов перевірки, відпівдю буде довжиною вхідного рядка.</p>\n<p>Як же перевірити чи можливий рядок з певною довжиною? Для цього необхідно перевірити на рівність відповідні символи. Наприклад символ з індексом 1 повинен дорівнювати символу з індексом 1 + l, індексом 2 - 2 + l і т. д. , де l - це довжина рядка, яка перевіряється:</p>\n<pre>\n// вхідний рядок\nchar S[5000];\nint find_min_string()\n{\n	// довжина вхідного рядку\n	int l = strlen(S);\n	// поточна довжина можливого рядку\n	int lenth = 0;\n	// ознака знаходження найкоротшого можливого рядка\n	bool flag = true;\n	// починати з мінімальної можливої довжини\n	for (int i = 1; i < l; i++)\n	{\n		flag = true;\n		// перевірка чи всі символи співпадуть, якщо поточний символ вважати почтком рядку\n		for (int j = 0; j < l - i; j++)\n		{\n			// якщо відповідні символи не співпадають\n			if (S[j] != S[i + j])\n			{\n				// поточний символ не може бути початком рядку\n				flag = false;\n				// припинити перевірку\n				break;\n			}\n		}\n		// якщо поточний символ може бути початком рядку\n		if (flag)\n		{\n			// його позицію записати як мінімальну можливу довжину рядка (так як ми рухаємося від найменшого, це гарантує знаходження саме мінімального рядка)\n			lenth = i;\n			// зупинити пошуки\n			break;\n		}\n	}\n	return lenth;\n}\n</pre>\n<p>У разі, якщо якась пара символів не рівні, змінна flag набуде хибного значення, що означатиме, що рядок з поточною довжиною не можливий, збільшимо поточну довжину на 1 та перевіримо новий рядок.</p>\n', '#include <iostream>\n#include <string.h>\nusing namespace std;\n\nchar S[5000]; // вхідний рядок\n\n//вивести список символів\nvoid show_symbols()\n{\n	int i = 0; // поточний символ рядку\n	while (S[i] != ''\\0'')\n	{\n		cout << i + 1 << ": " << S[i] << " ";\n		i++;\n	}\n	cout << endl;\n}\n\n// знайти даожини мінімального можливого рядка\nint find_min_string()\n{\n	int l = strlen(S); // довжина вхідного рядку\n	int lenth = 0; // поточна довжина можливого рядку\n	bool flag = true; // ознака знаходження найкоротшого можливого рядка\n	cout << "To see next step press any key" << endl;\n	for (int i = 1; i < l; i++) // починати з мінімальної можливої довжини\n	{\n		cout << "Cheking if string with lenth " << i << " is possible:" << endl;\n		flag = true;\n		getchar();\n		cout << "--------------------------------------------------" << endl;\n		// перевірка чи всі символи співпадуть, якщо поточний символ вважати почтком рядку\n		for (int j = 0; j < l - i; j++)\n		{\n			if (S[j] != S[i + j]) // якщо відповідні символи не співпадають\n			{\n				cout << j + 1 << " symbol (" << S[j] << ") not equal to " << i + j + 1 << " symbol (" << S[i + j] << ")" << endl;\n				cout << "Current string is not possible. Let''s find other variants." << endl;\n				flag = false; // поточний символ не може бути початком рядку\n				break; // припинити перевірку\n			}\n			else\n				cout << j + 1 << " symbol (" << S[j] << ") = " << i + j + 1 << " symbol (" << S[i + j] << ")" << endl;\n		}\n		if (flag) // якщо поточний символ може бути початком рядку\n		{\n			lenth = i; // його позицію записати як мінімальну можливу довжину рядка (так як ми рухаємося від найменшого, це гарантує знаходження саме мінімального рядка)\n			break;  // зупинити пошуки\n		}\n	}\n	return lenth;\n}\n\nint main()\n{\n	cout << "String S is written many times in a row. The part of this row are given to you." << endl;\n	cout << "You should find lenth of minimal possible string S" << endl;\n	cout << "Input repeated string: ";\n	gets(S); // ввести рядок\n	show_symbols();\n	int answer = find_min_string(); // остаточна відповідь\n	cout << "Current string is possible. So it''s lenth is minimal possible case: ";\n	cout << answer << endl;\n	system("pause");\n}'),
(4, '<h2>Живопис</h2>\n<p>Дана матриця N*M з клітинками, пофарбованими в чорний, або в білий кольори. W — ціна перефарбування чорного квадрата в білий, B — білого в чорний. Після перефарбування, між всіми сусідніми квадратами різних кольорів потрібно провести сіру лінію, ціною G. Потрібно так оптимально перефарбувати матрицю (або нічого не робити), щобпотратити мінімальну суму.</p>\n\n<h2>Рішення</h2>\n<p>Крайній випадок: якщо матриця вся одного кольору - відповідь 0.</p>\n<p>Додамо фіктивні джерело та стік. Від джерела до всіх білих вершин проведемо ребра, вагою в B (ціна перефарбовування в чорний).</p>\n<p>Від чорних вершин до стоку проведемо ребра, вагою в W (ціна перефарбовування в білий).</p>\n<p>І між усіма сусідніми вершинами (будь вони одного або різних кольорів) - ставимо ребро вагою в G (сіра лінія).</p>\n<p>Величина максимального потоку буде відповіддю на завдання.</p>\n<h2>Повний розбір</h2>\n<p>Для початку реалізуємо введення матриці з кольоровими клітинами:</p>\n<pre>\n// матриця кольорів\nint** colors;\ncolors = new int*[N];\ncout << "Input colors. 1 - White, 2 - Black" << endl;\n// ввести матрицю кольорів\nfor (int i = 0; i < N; i++)\n{\n	colors[i] = new int[M];\n	for (int j = 0; j < M; j++)\n	{\n		cout << "Color of element " << i + 1 << " " << j + 1 << ": ";\n		cin >> colors[i][j];\n	}\n}\n</pre>\n<p>Тепер, маючи матрицю кольорів, ми можемо створити відповідну мережу. Нагадаю за яким принципом ми це робитимемо:</p>\n<p>1.Від джерела до всіх білих вершин проведемо ребра, вагою в B (ціна перефарбовування в чорний).</p>\n<p>2.Від чорних вершин до стоку проведемо ребра, вагою в W (ціна перефарбовування в білий).</p>\n<p>3.Між усіма сусідніми вершинами (будь вони одного або різних кольорів) - ставимо ребро вагою в G (сіра лінія).</p>\n<p>Створену мережу ми зберігатимемо у вигляді матриці пропускних спроможностей, адже вона буде необхідна при пошуках максимального потоку:</p>\n<pre>\n// перетворити матрицю кольорів в мережу\nvoid make_net()\n{\n	// к-сть вершин в мережі (також додоємо джерело та стік)\n	int n = M*N + 2;\n	// створення матриці пропускних спроможностей\n	capacity = new int*[n]; \n	for (int i = 0; i < n; i++)\n	{\n		capacity[i] = new int[n];\n		for (int j = 0; j < n; j++)\n			capacity[i][j] = 0;\n	}\n	//обхід вхідної матриці кольорів та заповнення матриці пропускних спроможностей\n	for (int i = 0; i < N; i++)\n		for (int j = 0; j < M; j++)\n		{\n			// джерело приєднаємо до всіх білих вершин\n			if (colors[i][j] == 1)  \n				// з вагою ребра В\n				capacity[0][i*M + j + 2] = B; \n			// а стік - до чорних\n			else					\n				// з вагою ребра W\n				capacity[i*M + j + 2][1] = W; \n			// всі сусідні вершини, не зважаючи на колір з''єднаємо ребром вагою G\n			if (i > 0)\n				capacity[i*M + j + 2][(i - 1)*M + j + 2] = G;\n			if (i < N - 1)\n				capacity[i*M + j + 2][(i + 1)*M + j + 2] = G;\n			if (j > 0)\n				capacity[i*M + j + 2][i*M + j + 1] = G;\n			if (j < M - 1)\n				capacity[i*M + j + 2][i*M + j + 3] = G;\n		}\n\n}\n</pre>\n<p>Створивши мержу, ми можемо знайти максимальний потік. Для прикладу наведемо знаходження максимального потоку за алгоритмом Форда-Фалкерсона.</p>\n<p>Опис цього алгоритму можна прочитати <a href="http://77.47.239.14/rgr/theory/?t=4">тут</a>:</p>\n<pre>\n//знаходження максимального потоку\n// алгоритм Форда-Фалкерсона\nvoid max_flow()\n{\n	// 0 - джерело; 1 - стік\n	// к-сть вершин в мережі\n	int n = M*N + 2;\n	// потік\n	int** flow = new int*[n];\n	// створення матриці потоку\n	for (int i = 0; i < n; i++)\n	{\n		flow[i] = new int[n];\n		for (int j = 0; j < n; j++)\n			flow[i][j] = 0;\n	}\n	// ознака збільшення потоку\n	bool flag = true;\n	// поки потік збільшується\n	while (flag)\n	{\n		// потік ще не збільшився\n		flag = false;\n		// множина вершин, які можуть збільшити потік (необхідна бібліотека <list>)\n		list<int> M;\n		// масив резервів вершин\n		int* reserve = new int[n];\n		// попередник вершини, для встановлення шляху\n		int* path = new int[n];\n		for (int i = 0; i < n; i++)\n		{\n			reserve[i] = 0;\n			path[i] = 0;\n		}\n		// резерв джерела - нескінченність\n		reserve[0] = 999999;\n		M.push_back(0);\n		// якщо є вершини, які можуть збільшити потік\n		while (!M.empty()) \n		{\n			// ознака знаходження шляху від джерела до стоку\n			bool full_way = false;\n			// взяти довільну вершину з М\n			int v = M.front();\n			// та видалити цю вершину з М\n			M.pop_front();\n			for (int i = 0; i < n; i++)\n			{\n				// якщо з v в i(поточна вершина) існує ребро, пропускна здатність\n				якого більша за поточний потік через це ребро та i ще не відвідано\n				if (capacity[v][i] != 0 && reserve[i] == 0 && flow[v][i] < capacity[v][i])\n				{\n					// встановити резерв і як мінімум з резерву v та різницею\n					reserve[i] = MIN(reserve[v], (capacity[v][i] - flow[v][i]));\n					пропускної спроможності та потоку в поточному ребрі\n					// v - попередник i\n					path[i] = v;\n					// якщо і - не стік\n					if (i != 1)\n						M.push_back(i);\n					// інакше пройдено шлях від джерела до стоку\n					else\n						full_way = true;\n				}\n				// якщо з і(поточна вершина) в v існує ребро, через яке потік не 0 та i ще не відвідано\n				else\n				if (capacity[i][v] != 0 && reserve[i] == 0 && flow[i][v] > 0)\n				{\n					// встановити резерв і як мінімум з резерву v та потоку в поточному ребрі\n					reserve[i] = MIN(reserve[v], flow[i][v]);\n					// v - попередник i, через зворотнє ребро\n					path[i] = -v;\n					M.push_back(i);\n				}\n			}\n			// якщо пройдено шлях від джерела до стоку\n			if (full_way)\n			{\n				// відновити пройдений шлях\n				for (int i = 1; i > 0; i = abs(path[i]))\n				{\n					if (path[i] >= 0)\n						// ребру з правильною орієнтацією збільшити потік на резерв стоку\n						flow[path[i]][i] += reserve[1];\n					else\n						// ребру з протилежною орієнтацією зиеншити потік на резерв стоку\n						flow[i][abs(path[i])] -= reserve[1];\n				}\n				delete path;\n				delete reserve;\n				M.clear();\n				// потік збільшився\n				flag = true;\n				break;\n			}\n		}\n	}\n}\n</pre>\n<p>Тепер необхідно порахувати максимальний потік. Є декілька варіантів це зробити. Наприклад порахувати потік всіх ребер, що виходять з джерела:</p>\n<pre>\nint answer = 0;\n// вартість мінімального перефарбування\nfor (int i = 0; i < n; i++)\n	answer += flow[0][i];\n</pre>\n<p>Отриманий результат і буде мінімальною затратою на перефарбування матриці.</p>', '#include <iostream>\n#include <iomanip>\n#include <list> // бібліотека списків\n#define MIN(a,b) ((a) < (b) ? (a) : (b)) // знайти мін. значення\n\nusing namespace std;\n\nint N, M, W, B, G; // NxM розміри матриці, W - ціна перефарбування в білий колір B - чорний ,G - сірий\nint answer = 0; // вартість мінімального перефарбування\nint** colors; // матриця кольорів\nint** capacity; // пропускна здатність\nint** flow; // потік\n\n// перетворити матрицю кольорів в мережу\nvoid make_net()\n{\n	int n = M*N + 2; // к-сть вершин в мережі (також додоємо джерело та стік)\n	capacity = new int*[n]; \n	// створення матриці пропускних спроможностей\n	for (int i = 0; i < n; i++)\n	{\n		capacity[i] = new int[n];\n		for (int j = 0; j < n; j++)\n			capacity[i][j] = 0;\n	}\n	//обхід вхідної матриці кольорів та заповнення матриці пропускних спроможностей\n	for (int i = 0; i < N; i++)\n		for (int j = 0; j < M; j++)\n		{\n			if (colors[i][j] == 1)   // джерело приєднаємо до всіх білих вершин\n				capacity[0][i*M + j + 2] = B;  // з вагою ребра В\n			else					 // а стік - до чорних\n				capacity[i*M + j + 2][1] = W;  // з вагою ребра W\n			// всі сусідні вершини, не зважаючи на колір з''єднаємо ребром вагою G\n			if (i > 0)\n				capacity[i*M + j + 2][(i - 1)*M + j + 2] = G;\n			if (i < N - 1)\n				capacity[i*M + j + 2][(i + 1)*M + j + 2] = G;\n			if (j > 0)\n				capacity[i*M + j + 2][i*M + j + 1] = G;\n			if (j < M - 1)\n				capacity[i*M + j + 2][i*M + j + 3] = G;\n		}\n	cout << "Capacity matrix of created net:" << endl;\n	cout << "    ";\n	for (int i = 0; i < n; i++)\n		cout << setw(3) << i;\n	cout << "\\n--------------------------" << endl;\n	for (int i = 0; i < n; i++)\n	{\n		cout << setw(3) << i << "|";\n		for (int j = 0; j < n; j++)\n			cout << setw(3) << capacity[i][j];\n		cout << endl;\n	}\n}\n\n// вивід поточного стану мережі\nvoid output()\n{\n	int n = M*N + 2;\n	cout << "  Edges     Flow" << endl;\n	for (int i = 0; i < n; i++)\n	{\n		for (int j = 0; j < n; j++)\n		{\n			if (capacity[i][j] != 0)\n				cout << setw(3) << i << " ->" << setw(3) << j << setw(5) << flow[i][j] << endl;\n		}\n	}\n	cout << "-------------------------" << endl;\n}\n\n//знаходження максимального потоку\nvoid max_flow()\n{\n	// алгоритм Форда-Фалкерсона\n	// 0 - джерело; 1 - стік\n	int n = M*N + 2; // к-сть вершин в мережі\n	flow = new int*[n];\n	// створення матриці потоку\n	for (int i = 0; i < n; i++)\n	{\n		flow[i] = new int[n];\n		for (int j = 0; j < n; j++)\n			flow[i][j] = 0;\n	}\n	bool flag = true; // ознака збільшення потоку\n	while (flag) // поки потік збільшується\n	{\n		flag = false; // потік ще не збільшився\n		list<int> M; // множина вершин, які можуть збільшити потік\n		int* reserve = new int[n]; // масив резервів вершин\n		int* path = new int[n]; // попередник вершини, для встановлення шляху\n		for (int i = 0; i < n; i++)\n		{\n			reserve[i] = 0;\n			path[i] = 0;\n		}\n		reserve[0] = 999999; // резерв джерела - нескінченність\n		M.push_back(0);\n		while (!M.empty())  // якщо є вершини, які можуть збільшити потік\n		{\n			bool full_way = false; // ознака знаходження шляху від джерела до стоку\n			int v = M.front(); // взяти довільну вершину з М\n			M.pop_front(); // та видалити цю вершину з М\n			for (int i = 0; i < n; i++)\n			{\n				// якщо з v в i(поточна вершина) існує ребро, пропускна здатність якого більша за поточний потік через це ребро та i ще не відвідано\n				if (capacity[v][i] != 0 && reserve[i] == 0 && flow[v][i] < capacity[v][i])\n				{\n					reserve[i] = MIN(reserve[v], (capacity[v][i] - flow[v][i])); // встановити резерв і як мінімум з резерву v та різницею пропускної спроможності та потоку в поточному ребрі\n					path[i] = v; // v - попередник i\n					if (i != 1) // якщо і - не стік\n						M.push_back(i);\n					else // інакше пройдено шлях від джерела до стоку\n						full_way = true;\n				}\n				else\n					// якщо з і(поточна вершина) в v існує ребро, через яке потік не 0 та i ще не відвідано\n				if (capacity[i][v] != 0 && reserve[i] == 0 && flow[i][v] > 0)\n				{\n					reserve[i] = MIN(reserve[v], flow[i][v]); // встановити резерв і як мінімум з резерву v та потоку в поточному ребрі\n					path[i] = -v; // v - попередник i, через зворотнє ребро\n					M.push_back(i);\n				}\n			}\n			if (full_way) // якщо пройдено шлях від джерела до стоку\n			{\n				getchar();\n				cout << "Way wich can increase flow is found: ";\n				// відновити пройдений шлях\n				for (int i = 1; i > 0; i = abs(path[i]))\n				{\n					cout << i << " <- ";\n					if (path[i] >= 0)\n						flow[path[i]][i] += reserve[1]; // ребру з правильною орієнтацією збільшити потік на резерв стоку\n					else\n						flow[i][abs(path[i])] -= reserve[1]; // ребру з протилежною орієнтацією зиеншити потік на резерв стоку\n				}\n				cout << "0" << endl;\n				cout << "Current flow:" << endl;\n				output();\n				delete path;\n				delete reserve;\n				M.clear();\n				flag = true; // потік збільшився\n				break;\n			}\n		}\n	}\n	// порахувати максимальний потік як потік через розріз S/T, де S містить лиже джерело\n	for (int i = 0; i < n; i++)\n		answer += flow[0][i];\n	for (int i = 0; i < n; i++)\n	{\n		delete flow[i];\n		delete capacity[i];\n	}\n}\n\nint main()\n{\n	cout << "Input matrix size (NxM): ";\n	cin >> N >> M;\n	cout << "Input cost of recoloring to White, Black and Gray: ";\n	cin >> W >> B >> G;\n	colors = new int*[N];\n	cout << "Input colors. 1 - White, 2 - Black" << endl;\n	// ввести матрицю кольорів\n	for (int i = 0; i < N; i++)\n	{\n		colors[i] = new int[M];\n		for (int j = 0; j < M; j++)\n		{\n			cout << "Color of element " << i + 1 << " " << j + 1 << ": ";\n			cin >> colors[i][j];\n		}\n	}\n	cout << "Entered color matrix:" << endl;\n	cout << "   ";\n	for (int i = 0; i < M; i++)\n		cout << setw(2) << i+1;\n	cout << "\\n----------------" << endl;\n	for (int i = 0; i < N; i++)\n	{\n		cout << setw(2) << i+1 << "|";\n		for (int j = 0; j < M; j++)\n			cout << setw(2) << colors[i][j];\n		cout << endl;\n	}\n	cout << "Lets convert this matrix to the net" << endl;\n	cout << "Add source and connect it to all white vertexes and sink - to black" << endl;\n	cout << "Source - is vertex 0, sink - 1. Other vertexes you can define by formula:" << endl;\n	cout << "[i*M + j + 2] , where i - number of row, j - column M - lenth of row" << endl;\n	make_net();\n	cout << "Now we need to find maximum flow - it will be an answer" << endl;\n	cout << "To see next step press any key" << endl;\n	max_flow();\n	cout << "Way wich can increase flow is not found" << endl;\n	cout << "________________________________________" << endl;\n	cout << "So, minimum prise you can pay is: ";\n	cout << answer << endl;\n	system("pause");\n}');
INSERT INTO `cource` (`id`, `theory`, `example`) VALUES
(5, '<a href="http://acmp.ru/index.asp?main=task&id_task=101"><h2>Умова</h2></a>\n\n<h2>Розвязок</h2>\n<p>Дана задача схожа з задачею про ферзі, в якій необхідно знайти максимальну можливу к-сть ферзів, які можна розставити на шахматній дошці, і які не б/''ють одне одного.</p>\n<p>Така задача розв''язується за допомогою бектрекінгу.</p>\n<p>В нашій задачі ми також будемо використовувати цей метод. Але тепер ми намагатимемося розставити, задану к-сть магарадж на дошці. Якщо нам вдалося це зробити, то це один із можливих варіантів розстановки. Додамо до к-сті варіантів 1.</p>\n<p>Розглянувши всі можливі випадки, ще потрібно врахувати, що не важливо яку фігуру ми ставимо першою, тому отриманий результат необхідно поділити на к-сть перемтановок фігур. Отримане число - остаточна відповідь.</p>\n<p>Вказаний алгоритм можна оптимізувати. Так як шахматна дошка симетрична, то нам достатньо розглянути лише частину можливих розстановок першої фігури. А саме клітинки, що утворюють трикутник в чверті дошки. Решта клітин буде симетрична одній з вказаних. Потрібно лише визначити к-сть симетричних клітин.</p>\n<p>Наприклад, є 4 кутових клітини. Тому нам достатньо знайти к-сть варіантів для одної та домножити її на 4(к-сть кутових клітин).</p>\n<p>Також, не потрібно ставити останню фігуру, потрібно просто порахувати к-сть клітин, в які її можна поставити. К-сть цих клітин і буде к-стю можливих випадків для даної конфігурації решти фігур.</p>\n<p><h2>Повний розбір</h2></p>\n<p>Для початку створимо дошку, на яку ставитимемо фігури:</p>\n<pre>\nint** desk = new int*[N];\nfor (int i = 0; i < N; i++)\n{\n	desk[i] = new int[N];\n	for (int j = 0; j < N; j++)\n		desk[i][j] = 0;\n}\n</pre>\n<p>0 означає, що на цю клітину можна поставити фігуру.</p>\n<p>Далі напишемо ф-цію, яка ставить фігуру на дошку:</p>\n<pre>\n// індекс рядка та стовпчика, куди ставимо магараджу\nvoid put_magaraja(int a, int b)\n{\n	// Магараджа б''є будь-яку фігуру, що знаходиться в районі 3х3\n	клітки навколо магараджіб тому позначимо цю зону\n	// якщо над фігурою є 2 рядка, то помітити їх частину\n	if (a > 1)\n	// помітити тільки 2 клітини зліва та справа від магараджі\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n	{\n		desk[a - 2][j]++; \n		desk[a - 1][j]++;\n	}\n	else\n	// якщо один рядок, то помітити його частину\n	if (a > 0)\n	// помітити тільки 2 клітини зліва та справа від магараджі\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n		desk[a - 1][j]++;\n	// якщо під фігурою є 2 рядка, то помітити їх частину\n	if (a < N-2)\n	// помітити тільки 2 клітини зліва та справа від магараджі\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n	{\n		desk[a + 2][j]++;\n		desk[a + 1][j]++;\n	}\n	else\n	// якщо над фігурою є 1 рядок, то помітити його частину\n	if (a < N - 1)\n	// помітити тільки 2 клітини зліва та справа від магараджі\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n		desk[a + 1][j]++;\n	for (int i = 0; i < N; i++)\n	{\n		// помітити всі клітини по горизонталі та вертикалі\n		desk[a][i]++;\n		desk[i][b]++;\n		// помітити всі клітини по діагоналям\n		if (a - i >= 0)\n		{\n			if (b - i >= 0)\n				desk[a - i][b - i]++;\n			if (b + i < N)\n				desk[a - i][b + i]++;\n		}\n		if (a + i < N)\n		{\n			if (b + i < N)\n				desk[a + i][b + i]++;\n			if (b - i >= 0)\n				desk[a + i][b - i]++;\n		}\n	}\n	// позначити місцеположення фігури\n	desk[a][b] += 1000;\n}\n</pre>\n<p>Як бачимо, значення відмінне від 0 означає, що на цю клітину не можна поставити фігуру, бо її полю''є інша фігура.</p>\n<p>Також напишемо функцію, яка прибиратиме фігуру з дошки. Вона відрізнятиметься від попередньої лиш в тому, що ми відніматимемо 1 від поточного значення клітини 1, а не додавтимо:</p>\n<pre>\nvoid get_of_magaraja(int a, int b)\n{\n	if (a > 1)\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n	{\n		desk[a - 2][j]--;\n		desk[a - 1][j]--;\n	}\n	else\n	if (a > 0)\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n		desk[a - 1][j]--;\n	if (a < N - 2)\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n	{\n		desk[a + 2][j]--;\n		desk[a + 1][j]--;\n	}\n	else\n	if (a < N - 1)\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n		desk[a + 1][j]--;\n\n	for (int i = 0; i < N; i++)\n	{\n		desk[a][i]--;\n		desk[i][b]--;\n		if (a - i >= 0)\n		{\n			if (b - i >= 0)\n				desk[a - i][b - i]--;\n			if (b + i < N)\n				desk[a - i][b + i]--;\n		}\n		if (a + i < N)\n		{\n			if (b + i < N)\n				desk[a + i][b + i]--;\n			if (b - i >= 0)\n				desk[a + i][b - i]--;\n		}\n	}\n	desk[a][b] -= 1000;\n}\n</pre>\n<p>Тепер ми маємо все необхідне, щоб перебрати всі можливі варіанти.</p>\n<p>Почнемо з першої фігури. Як було сказано раніше, нам не обов''язково ставити першу фігуру на всі клітини. Достатньо розглянути лиш декілька. А саме:</p>\n<p>1. Кутові клітинки ( з рівними індексами). Таких клітин завжди 4. Але у випадку непарного N, центральна клітина не матиме аналогів, тому 1.</p>\n<p>2. Бічні клітини. Зазвичай є 8 симетричних бічних клітин, але у випадку непарного N середні клітини зустрічатимуться по 4.</p>\n<p>Нагадаю, що розгладатимемо такі клітини лише в 1 чверті дошки, адже всі чверті між собою симетричні:</p>\n<pre>\n// якщо магараджа лише одна\nif (K == 1)\n	// то к-сть клітинок на дошці і буде відповіддю\n	answer = N*N;\nelse\n{\n	// для першої фігури достатньо розглянути частину випадків\n	(трикутник чверті дошки), решта будуть аналогічними\n	for (int i = 0; i < (N + 1) / 2; i++)\n		for (int j = 0; j <= i; j++)\n		{\n			// обнулити к-сть варіантів для підрахунку варіантів у наступному випадку\n			variants = 0;\n			put_magaraja(i, j);\n			// розглянути всі випадки для 2 фігури\n			Solution(2);\n			get_of_magaraja(i, j);\n			// якщо це середній (для непарних N) стовпчик\n			if (i == N / 2)\n			{\n				// якшо поточний елемент центральний\n				if (i == j)\n					// то такий випалок лише один\n					answer += variants;\n				//якщо, ні, то цей елемент знаходиться в середині рядку\n				else\n					// тоді таких випадків 4\n					answer += 4 * variants;\n			}\n			// якщо стовпчик не останній\n			else\n			{\n				// якщо кутовий елеммент\n				if (i == j)\n					// то можливі 4 аналогічних випадка\n					answer += 4 * variants;\n				// якщо ж елемент не кутовий, то це\n				довільний(не середній) едемент рядка\n				else\n					// тоді таких аналогічних випадків 8\n					answer += 8 * variants;\n			}\n		}\n}\n</pre>\n<p>Нажаль для наступних фігур, таку симетричність знайти важче (якщо взагалі можливо), тому будемо розглядати всі клітини. Ставитимемо фігури, доки не поставимо вказану к-сть, або поки не залишиться вільних клітинок. Повторюватимо, доки не переберемо всі випадки:</p>\n<pre>\nvoid Solution(int k) // номер фігури, яку ставимо на дошку\n{\n	// якщо залишилась остання фігура, то підрахувати всі можливі варіанти її розстановки\n	if (k == K)\n	{\n		for (int i = 0; i < N; i++)\n			for (int j = 0; j < N; j++)\n				if (desk[i][j] == 0)\n					variants++;\n	}\n	// інакше по черзі розглянути всі можливі варіанти розстановки поточної фігури\n	else\n	{\n		for (int i = 0; i < N; i++)\n			for (int j = 0; j < N; j++)\n				if (desk[i][j] == 0)\n				{\n					put_magaraja(i, j);\n					Solution(k + 1);\n					get_of_magaraja(i, j);\n				}\n	}\n}\n</pre>\n<p>Все, що нам залишилось, це поділити на к-сть перестановок фігур, яка шукається за формулою K!:</p>\n<pre>\nint divide = 1; // к-сть перестановок\n// знаходимо к-сть перестановок магарадж (К!)\nfor (int i = 1; i <= K; i++)\n	divide *= i;\n	</pre>\n<p>Остаточною відповіддю буде:</p>\n<pre>\nanswer /= divide;\n</pre>\n', '#include <iostream>\n\n#define MIN(a,b) ((a) < (b) ? (a) : (b)) // знайти мін. значення\n#define MAX(a,b) ((a) > (b) ? (a) : (b)) // знайти макс. значення\n\nusing namespace std;\n\nint N, K; // розмір шахматної дошки та к-сть магарадж\nint variants = 0, answer = 0; // поточна к-сть варіантів та остаточна відповідь\nint** desk; // шахматна дошка\n\n// поставити магараджу\nvoid put_magaraja(int a, int b) // індекс рядка та стовпчика, куди ставимо магараджу\n{\n	// Магараджа б''є любу фігуру, що знаходиться в районі 3х3 клітки навколо магараджіб тому позначимо цю зону\n	if (a > 1) // якщо над фігурою є 2 рядка, то помітити їх частину\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++) // помітити тільки 2 клітини зліва та справа від магараджі\n	{\n		desk[a - 2][j]++; \n		desk[a - 1][j]++;\n	}\n	else\n	if (a > 0) // якщо один рядок, то помітити його частину\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++) // помітити тільки 2 клітини зліва та справа від магараджі\n		desk[a - 1][j]++;\n	if (a < N-2) // якщо під фігурою є 2 рядка, то помітити їх частину\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++) // помітити тільки 2 клітини зліва та справа від магараджі\n	{\n		desk[a + 2][j]++;\n		desk[a + 1][j]++;\n	}\n	else\n	if (a < N - 1) // якщо над фігурою є 1 рядок, то помітити його частину\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++) // помітити тільки 2 клітини зліва та справа від магараджі\n		desk[a + 1][j]++;\n\n	for (int i = 0; i < N; i++)\n	{\n		// помітити всі клітини по горизонталі та вертикалі\n		desk[a][i]++;\n		desk[i][b]++;\n		// помітити всі клітини по діагоналям\n		if (a - i >= 0)\n		{\n			if (b - i >= 0)\n				desk[a - i][b - i]++;\n			if (b + i < N)\n				desk[a - i][b + i]++;\n		}\n		if (a + i < N)\n		{\n			if (b + i < N)\n				desk[a + i][b + i]++;\n			if (b - i >= 0)\n				desk[a + i][b - i]++;\n		}\n	}\n	desk[a][b] += 1000; // позначити місцеположення фігури\n}\n\n// прибрати магараджу (аналогічна попередній ф-ції, тільки навпаки, прибираєму помітки)\nvoid get_of_magaraja(int a, int b)\n{\n	if (a > 1)\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n	{\n		desk[a - 2][j]--;\n		desk[a - 1][j]--;\n	}\n	else\n	if (a > 0)\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n		desk[a - 1][j]--;\n	if (a < N - 2)\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n	{\n		desk[a + 2][j]--;\n		desk[a + 1][j]--;\n	}\n	else\n	if (a < N - 1)\n	for (int j = MAX(0, b - 2); j < MIN(N, b + 3); j++)\n		desk[a + 1][j]--;\n\n	for (int i = 0; i < N; i++)\n	{\n		desk[a][i]--;\n		desk[i][b]--;\n		if (a - i >= 0)\n		{\n			if (b - i >= 0)\n				desk[a - i][b - i]--;\n			if (b + i < N)\n				desk[a - i][b + i]--;\n		}\n		if (a + i < N)\n		{\n			if (b + i < N)\n				desk[a + i][b + i]--;\n			if (b - i >= 0)\n				desk[a + i][b - i]--;\n		}\n	}\n	desk[a][b] -= 1000;\n}\n\n// вивести поточний стан дошки\nvoid output()\n{\n	for (int i = 0; i < N; i++)\n	{\n		for (int j = 0; j < N; j++)\n		{\n			if (desk[i][j] > 1000)\n				cout << "M ";\n			else\n			{\n				if (desk[i][j] == 0)\n					cout << "0 ";\n				else\n					cout << "x ";\n			}\n		}\n		cout << endl;\n	}\n	cout << endl;\n}\n\n// перебір варіантів\nvoid Solution(int k) // номер фігури, яку ставимо на дошку\n{\n	if (k == K) // якщо залишилась остання фігура, то підрахувати всі можливі варіанти її розстановки\n	{\n		for (int i = 0; i < N; i++)\n			for (int j = 0; j < N; j++)\n				if (desk[i][j] == 0)\n					variants++;\n	}\n	else // інакше по черзі розглянути всі можливі варіанти розстановки поточної фігури\n	{\n		for (int i = 0; i < N; i++)\n			for (int j = 0; j < N; j++)\n				if (desk[i][j] == 0)\n				{\n					put_magaraja(i, j);\n					//getchar();\n					output();\n					Solution(k + 1);\n					get_of_magaraja(i, j);\n				}\n	}\n}\n\n// почати підрахунок варіантів\nvoid start()\n{\n	if (K == 1) // якщо магараджа лише одна\n		answer = N*N; // то к-сть клітинок на дошці і буде відповіддю\n	else\n	{\n		// для першої фігури достатньо розглянути частину випадків (трикутник чверті дошки), решта будуть аналогічними\n		for (int i = 0; i < (N + 1) / 2; i++)\n			for (int j = 0; j <= i; j++)\n			{\n				variants = 0; // обнулити к-сть варіантів для підрахунку варіантів у наступному випадку\n				put_magaraja(i, j);\n				getchar();\n				cout << "Position of first figure:" << endl;\n				cout << "---------------" << endl;\n				output();\n				if (K>2)\n					cout << "All possible position of next figures: " << endl;\n				Solution(2); // розглянути всі випадки для 2 фігури\n				get_of_magaraja(i, j);\n				if (i == N / 2) // якщо це середній (для непарних N) стовпчик\n				{\n					if (i == j) // якшо поточний елемент центральний\n						answer += variants; // то такий випалок лише один\n					else  //якщо, ні, то цей елемент знаходиться в середині рядку\n						answer += 4 * variants; // тоді таких випадків 4\n				}\n				else // якщо стовпчик не останній\n				{\n					if (i == j) // якщо кутовий елеммент\n						answer += 4 * variants; // то можливі 4 аналогічних випадка\n					else // якщо ж елемент не кутовий, то це довільний(не середній) едемент рядка\n						answer += 8 * variants; // тоді таких аналогічних випадків 8\n				}\n				cout << "all variants for this case: " << variants << endl;\n			}\n	}\n}\n\nint main()\n{\n	cout << "Made by Yevhen Serdiuk, IS-41, FICT" << endl;\n	cout << "Magaraja it''s chess figure wich can move like queen and horse." <<\n		"\\nYou need to find all variants how to put K(number of figures) this figures on desk NxN." << endl;\n	cout << "To find out number of variants we need to put K-1 figures on desk and calculate all possible position of last figure." <<\n		"\\nDo it for every variant, but for the first figure we should''t check all cases" << endl;\n	cout <<"We need to check just element in triangle in one fourth of desk." << endl;\n	cout << "Input N(size of the desk) and K(number of figures)" << endl;\n	cin >> N >> K;\n	cout << "To see next step press any key" << endl;\n	desk = new int*[N];\n	for (int i = 0; i < N; i++)\n	{\n		desk[i] = new int[N];\n		for (int j = 0; j < N; j++)\n			desk[i][j] = 0;\nint\n	start();\n	int divide = 1; // к-сть перестановок\n	// знаходимо к-сть перестановок магарадж (К!)\n	for (int i = 1; i <= K; i++)\n		divide *= i;\n	cout << "-------------------------------------" << endl;\n	cout << "Number of all possible variants: ";\n	cout << answer/divide << endl; // ділимо к-сть варіантів на к-сть перестановок, адже не важливо порядок з яким ми ставимо магарадж\n	for (int i = 0; i < N; i++)\n		delete desk[i];\n	system("pause");\n}'),
(6, '<a href="http://acmp.ru/index.asp?main=task&id_task=656">Умова</a>\r\n\r\n<h2>Розв''язок</h2>\r\n<p>З умови випливає, що вхідний граф - дерево, адже не районні центри можуть бути з''єднані лише через районні центри.</p>\r\n<p>Відповідь шукатимемо шляхом відкидання "непотрібних" доріг. Такими дорогами є ребра дерева, що з''єднують термінальні вершини.</p>\r\n<p>Тобто, на кожній ітерації ми відкидатимо одне ребро. Яке саме визначаємо так:</p>\r\n<p>- Дане ребро з''єднує термінальну вершину.</p>\r\n<p>- Дане ребро є найдорожчим з усіх, що з''єднують термінальні вершини.</p>\r\n<p>Відкидатимо дороги, доки не залишиться вказана к-сть доріг.</p>\r\n\r\n<h2>Повний розбір</h2>\r\n<p>Зберегіти граф будемо у вигляді масиву ребер. Для цього створемо структуру для ребра:</p>\r\n<pre>\r\nstruct edge\r\n{\r\n	// початок ребра\r\n	int start;\r\n	// кінець ребра\r\n	int end;\r\n	// вага ребра\r\n	int veight;\r\n	// номер ребра\r\n	int number;\r\n};\r\n</pre>\r\n<p>При введені ребер графу, також будемо рахувати степені вершин, що знадобиться для визначення термінальних вершин:</p>\r\n<pre>\r\n// к-сть міст, доріг всього та доріг для покупки\r\nint n,m,k;\r\n// масив ребер\r\nedge* Edges = new edge[m];\r\n// масив з к-стю інцидентних ребер до кожної вершини\r\nint* vertexes = new int[n];\r\n// позначити степені всіх вершин 0 для подальшого їх обрахунку\r\nfor (int i = 0; i < n; i++)\r\n	vertexes[i] = 0;\r\ncout << "Input roads and their price:" << endl;\r\nfor (int i = 0; i < m; i++)\r\n{\r\n	cout << i + 1 << ": ";\r\n	cin >> Edges[i].start >> Edges[i].end >> Edges[i].veight;\r\n	// зберегти початковий номер ребра\r\n	Edges[i].number = i + 1;\r\n	// збільшити к-сть інцедентних ребер на 1 для початкової та кінцевої вершини\r\n	vertexes[Edges[i].start - 1] ++;\r\n	vertexes[Edges[i].end - 1] ++;\r\n}\r\n</pre>\r\n<p>Так як нам необхідно витратити якнайменше коштів, то відсортуємо масив ребер за вартістю. Для цого використаємо стандартну ф-цію qsort:</p>\r\n<p>qsort(Edges, m, sizeof(edge), comp);</p>\r\n<p>comp - це функція порівняння, в які нам необхідно вказати як нам порівнювати ребра:</p>\r\n<pre>\r\n// елементи, що порівнюються\r\nint comp(const void *i, const void *j)\r\n{\r\n	edge* a = (edge*)i;\r\n	edge* b = (edge*)j;\r\n	// порівнювати за вагою ребра\r\n	return (a->veight - b->veight); \r\n}\r\n</pre>\r\n<p>Тепер просто на кожному кроці із всіх ребер, що з''єднують термінальні вершини, видалятимемо найдорожчі доти, доки не залишиться вказана к-сть доріг:</p>\r\n<pre>\r\nfor (int i = 0; i < (m-k); i++)\r\n{\r\n	// починати з ребра найбільшої ваги\r\n	int j = m-1;\r\n	while (j >= 0)\r\n	{\r\n		// якщо ребро ще не відкинуте і одній з вершин інцидентне тільки це ребро\r\n		if (Edges[j].number!= 0 && (vertexes[Edges[j].start - 1] == 1 || vertexes[Edges[j].end - 1] == 1))\r\n		{\r\n			cout << "We shouldn''t buy road from " << Edges[j].start << " to " << Edges[j].end << "(delete this road from graph)" << endl;\r\n			// зменшити к-сть інцедентних ребер на 1 для початкової та кінцевої вершини ребра\r\n			vertexes[Edges[j].start-1] --;\r\n			vertexes[Edges[j].end-1] --;\r\n			// позначити поточне ребро як видалене\r\n			Edges[j].number = 0;\r\n			break;\r\n		}\r\n		j--;\r\n	}\r\n}\r\n</pre>\r\n<p>Ребра, що залишилися і є дорогами, які необхідно придбати:</p>\r\n<pre>\r\n// вивести ребра, що залишилися\r\ncout << "So, you need to buy this roads:" << endl;\r\nfor (int i = 0; i < m; i++)\r\n{\r\n	if (Edges[i].number != 0)\r\n		cout << Edges[i].number << ": " << Edges[i].start << " " << Edges[i].end << endl;\r\n}\r\n</pre>', '#include <iostream>\r\n#include <fstream>\r\n\r\nusing namespace std;\r\n\r\nstruct edge\r\n{\r\n	int start; // початок ребра\r\n	int end; // кінець ребра\r\n	int veight; // вага ребра\r\n	int number; // номер ребра\r\n};\r\n\r\nint n,m,k; // к-сть міст, доріг всього та доріг для покупки\r\nedge * Edges; // масив ребер\r\nint* vertexes; // масив з к-стю інцидентних ребер до кожної вершини\r\n\r\nint comp(const void *i, const void *j) // елементи, що порівнюються\r\n{\r\n	edge* a = (edge*)i;\r\n	edge* b = (edge*)j;\r\n	return (a->veight - b->veight);  // порівнювати за вагою ребра\r\n}\r\n\r\n// вивід проміжних результатів\r\nvoid output()\r\n{\r\n	cout << "--------------------------" << endl;\r\n	for (int i = 0; i < n; i++)\r\n	{\r\n		cout << i + 1 << ": ";\r\n		if (vertexes[i] == 0)\r\n			cout << "not connected";\r\n		else\r\n		{\r\n			for (int j = 0; j < m; j++)\r\n			{\r\n				if (Edges[j].number != 0 && (Edges[j].end == (i + 1) || Edges[j].start == (i + 1)))\r\n				{\r\n					if (Edges[j].end == (i + 1))\r\n						cout << Edges[j].start << " (" << Edges[j].veight <<") ";\r\n					else\r\n						cout << Edges[j].end << " (" << Edges[j].veight << ") ";\r\n				}\r\n			}\r\n		}\r\n		cout << endl;\r\n	}\r\n	cout << "--------------------------" << endl;\r\n}\r\n\r\n// прочитати файл\r\nvoid read()\r\n{\r\n	ifstream input("input.txt");\r\n	input >> n >> m >> k;\r\n	cout << "Yoy need to buy " << k << " roads" << endl;\r\n	Edges = new edge[m];\r\n	vertexes = new int[n];\r\n	// позначити степені всіх вершин 0 для подальшого їх обрахунку\r\n	for (int i = 0; i < n; i++)\r\n		vertexes[i] = 0;\r\n	cout << "Roads and their price:" << endl;\r\n	for (int i = 0; i < m; i++)\r\n	{\r\n		cout << i + 1 << ": ";\r\n		input >> Edges[i].start >> Edges[i].end >> Edges[i].veight;\r\n		cout << Edges[i].start << " " << Edges[i].end << " " << Edges[i].veight << endl;\r\n		Edges[i].number = i + 1; // зберегти початковий номер ребра\r\n		// збільшити к-сть інцедентних ребер на 1 для початкової та кінцевої вершини\r\n		vertexes[Edges[i].start - 1] ++;\r\n		vertexes[Edges[i].end - 1] ++;\r\n	}\r\n	qsort(Edges, m, sizeof(edge), comp);\r\n	input.close();\r\n}\r\n\r\nvoid input()\r\n{\r\n	cout << "Input number of towns, all roads and amount of roads to buy: ";\r\n	cin >> n >> m >> k;\r\n	Edges = new edge[m];\r\n	vertexes = new int[n];\r\n	// позначити степені всіх вершин 0 для подальшого їх обрахунку\r\n	for (int i = 0; i < n; i++)\r\n		vertexes[i] = 0;\r\n	cout << "Input roads and their price:" << endl;\r\n	for (int i = 0; i < m; i++)\r\n	{\r\n		cout << i + 1 << ": ";\r\n		cin >> Edges[i].start >> Edges[i].end >> Edges[i].veight;\r\n		Edges[i].number = i + 1; // зберегти початковий номер ребра\r\n		// збільшити к-сть інцедентних ребер на 1 для початкової та кінцевої вершини\r\n		vertexes[Edges[i].start - 1] ++;\r\n		vertexes[Edges[i].end - 1] ++;\r\n	}\r\n	qsort(Edges, m, sizeof(edge), comp); // сортування ребер за їх вагою\r\n}\r\n\r\nvoid Solution()\r\n{\r\n	//Заданий граф - дерево, тому для знаходження мінімального варіанту,\r\n	//відкидатимо термінальні вершини, до яких відстань найбільша\r\n	for (int i = 0; i < (m-k); i++)\r\n	{\r\n		getchar();\r\n		int j = m-1; // починати з ребра найбільшої ваги\r\n		while (j >= 0)\r\n		{\r\n			// якщо ребро ще не відкинуте і одній з вершин інцидентне тільки це ребро\r\n			if (Edges[j].number!= 0 && (vertexes[Edges[j].start - 1] == 1 || vertexes[Edges[j].end - 1] == 1))\r\n			{\r\n				cout << "We shouldn''t buy road from " << Edges[j].start << " to " << Edges[j].end << "(delete this road from graph)" << endl;\r\n				// зменшити к-сть інцедентних ребер на 1 для початкової та кінцевої вершини ребра\r\n				vertexes[Edges[j].start-1] --;\r\n				vertexes[Edges[j].end-1] --;\r\n				Edges[j].number = 0; // позначити поточне ребро як видалене\r\n				break;\r\n			}\r\n			j--;\r\n		}\r\n		output();\r\n	}\r\n	delete vertexes;\r\n}\r\n\r\nint main()\r\n{\r\n	cout << "Input graph is a tree. So to find out wich road we should buy" << endl;\r\n	cout << "we need to delete roads wich conect terminal vertex \\n(because we need to get a tree too) and are most expensive." << endl;\r\n	cout << "We will do it while left only entered amount of roads wich we can buy" << endl;\r\n	cout << "Read graph from example from file?[y/n]" << endl;\r\n	if (getchar() == ''n'') // якщо користувач вирішив ввести граф вручну\r\n		input();\r\n	else\r\n		read();\r\n	cout << "Input tree:" << endl;\r\n	cout << "List of vertexes. In scobes you can see price of this road" << endl;\r\n	output();\r\n	cout << "To go to the next step just press any key" << endl;\r\n	Solution();\r\n	// вивести ребра, що залишилися\r\n	cout << "So, you need to buy this roads:" << endl;\r\n	for (int i = 0; i < m; i++)\r\n	{\r\n		if (Edges[i].number != 0)\r\n			cout << Edges[i].number << ": " << Edges[i].start << " " << Edges[i].end << endl;\r\n	}\r\n	delete Edges;\r\n	system("pause");\r\n}');

-- --------------------------------------------------------

--
-- Table structure for table `tasks`
--

CREATE TABLE IF NOT EXISTS `tasks` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` char(30) NOT NULL DEFAULT 'Unnamed task',
  `prob` text NOT NULL,
  `example_in` text NOT NULL,
  `example_out` text NOT NULL,
  `test_in` text NOT NULL,
  `test_out` text NOT NULL,
  `topic` int(10) unsigned NOT NULL,
  `timelimit` int(11) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`),
  KEY `id` (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=45 ;

--
-- Dumping data for table `tasks`
--

INSERT INTO `tasks` (`id`, `name`, `prob`, `example_in`, `example_out`, `test_in`, `test_out`, `topic`, `timelimit`) VALUES
(5, 'Магараджа', 'Магараджа – це шахова фігура, що поєднує можливості ферзя та коня. Таким чином, магараджа може ходити та бити будь-яку кількість клітинок по діагоналі, горизонталі та вертикалі, а також або на дві клітинки по горизонталі та на одну по вертикалі, або на одну по горизонталі та на дві по вертикалі.\nВаша задача – знайти число способів розставити на дошці N на N рівно К магараджей так, щоб вони не били одна одну.\n<br><b>Вхідні дані</b>\n<br>Кожен тест містить два числа N та К (1 ≤ K ≤ N ≤ 10). \n<br><b>Вихідні дані</b>\n<br>Виведіть відповідь задачі.\n', '3 1\r\n\n||\n5 3\r\n', '9\r\n\n||\n48\r\n', '3 1\r\n\n||\n4 2\r\n\n||\n5 3\r\n\n||\n5 2\r\n\n||\n7 4\r\n\n||\n6 3\r\n\n||\n8 3\r\n', '9\r\n\n||\n20\r\n\n||\n48\r\n\n||\n92\r\n\n||\n1754\r\n\n||\n424\r\n\n||\n6616\r\n', 5, 1),
(4, 'Кількість дільників', 'Нехай х – натуральне число. Назвемо його дільником, якщо 1 <= у <= х та остача від ділення х на у = 0. \r\nДано число х. Знайдіть кількість його дільників.\r\n<br><b>Вхідні дані</b>\r\n<br>Міститься одне ціле число x (1 <= x <= 1018). Всі прості дільники х не більше 1000. \r\n<br><b>Вихідні дані</b>\r\n<br>Виведіть відповідь на задачу.\r\n\r\n', '12\r\n\n||\n239\r\n', '6\r\n\n||\n2\r\n', '12\r\n\n||\n239\r\n\n||\n1\r\n\n||\n7\r\n\n||\n204\r\n\n||\n491\r\n\n||\n513\r\n\n||\n1001\r\n\n||\n971\r\n\n||\n18\r\n', '6\r\n\n||\n2\r\n\n||\n1\r\n\n||\n2\r\n\n||\n12\r\n\n||\n2\r\n\n||\n8\r\n\n||\n8\r\n\n||\n2\r\n\n||\n6\r\n', 5, 1),
(6, 'Дріб', 'Вася вчиться у третьому класі та зараз проходить тему “Прості дроби з натуральними чисельником і знаменником”. Виявляється, що дріб називається простим, якщо його чисельним менший за знаменник і вони нескоротні. Вася любить математику, тому вдома розв”язує багато задач. Зараз Вася шукає найбільший правильний нескоротний дріб, у якого сума чисельника та знаменника = N.\r\nНапишіть програму, яка допоможе Васі це зробити.\r\n<br><b>Вхідні дані</b>\r\n<br>Міститься одне ціле число N (3 ≤ N ≤ 2∙109). \r\n<br><b>Вихідні дані</b>\r\n<br>Виведіть два числа – чисельник і знаменник знайденого дробу, розділені пробілом.\r\n', '3\r\n\n||\n10', '1 2\r\n\n||\n3 7', '3\r\n\n||\n10\r\n\n||\n12\n||\n20\n||\n31\n||\n38\n||\n104\n||\n194', '1 2\r\n\n||\n3 7\r\n\n||\n5 7\n||\n9 11\n||\n15 16\n||\n17 21\n||\n51 53\n||\n95 99', 1, 1),
(8, 'Фішки', 'На полі розмірністю один на 2*N+1 зліва знаходяться N білих, а справа  − N   чорних фішок. \r\nМожна робити наступні ходи:\r\nБілі фішки можуть рухатись лише направо, а чорні − лише наліво.\r\nДозволяється перемістити білу фішку на сусіднє пусте поле справа або перескочити рівно через одну чорну фішку, якщо за нею поле пусте. Чорну фішку можна перемістити на сусіднє пусте поле зліва або перескочити рівно через одну білу фішку, якщо за нею поле пусте. \r\nПронумеруємо білі фішки справа наліво, а чорні − зліва направо.\r\nПерша біла фішка позначається w1, друга − w2, N-та − wN. Аналогічно, перша чорна фішка позначається b1, друга − b2, N-та − bN.\r\nНаписати програму, яка дозволяє поміняти їх місцями, щоб справа стояли N білих, а зліва − N чорних. Результатом повинно бути послідовність фішок, які потрібно переміщувати. Починати переміщення потрібно з білої фішки.\r\n<br><b>Вхідні дані</b>\r\n<br>Ввести єдине число N (N≤500).\r\n<br><b>Вихідні дані</b>\r\n<br>Вивести у перший рядок кількість переміщень та вивести у другий рядок послідовність фішок, які будемо переміщувати.\r\n', '2\r\n', '8\r\nw1b1b2w1w2b1b2w2\r\n', '2\r\n', '8\r\nw1b1b2w1w2b1b2w2\r\n', 1, 1),
(10, 'Кола', 'Петрику дали особисте завдання додому – на папері розставили точки. Дані точки мають стати центрами для кіл однакового діаметру. Петрику необхідно намалювати ці кола таким чином, щоб жодне з них не перетиналось, але обов’язково була б хоча б одна пара кіл, що доторкаються одне до одного. Для виконання даної задачі у Петрика є спеціальний циркуль, який дозволяє вказувати значення квадрату діаметру для малювання кіл. Допоможіть Петрику знайти це значення.\r\n<br><b>Вхідні дані</b>\r\n<br>У першому рядку вхідного файлу вказане число N (1 <= N <= 30) – кількість помічених центрів кіл. У наступних N рядках вказані пари чисел через пробіл: x y (-1000 <= x, y <= 1000).\r\n<br><b>Вихідні дані</b>\r\n<br>Виведіть єдине число – значення квадрату діаметру, що необхідно ввести у електронний циркуль, щоб правильно виконати поставлене домашнє завдання.\r\n', '8 \r\n<br>951 -918 \r\n<br>-909 435 \r\n<br>769 -792 \r\n<br>465 978 \r\n<br>-691 -739 \r\n<br>-871 505 \r\n<br>36 -369 \r\n<br>-627 -190\r\n', '6344\r\n', '8 \r\n<br>951 -918 \r\n<br>-909 435 \r\n<br>769 -792 \r\n<br>465 978 \r\n<br>-691 -739 \r\n<br>-871 505 \r\n<br>36 -369 \r\n<br>-627 -190\r\n', '6344\r\n', 1, 1),
(11, 'Район', 'На дирекцію міста наклали штраф за низький рівень освітлення центрального району. Така неприємна ситуація склалась через масові висотні забудови на пагорбі на краю міста – N будинків розмістились на одній лінії і закривають собою сонячні промені. Позбавитись від даних забудов дирекція не може, але і витрачати гроші зі збережень на виплату штрафу також не бажає. У даному випадку фінансисти порадили дирекції штрафувати будівлі, що стоять на пагорбі. Як зазначили фінансисти: штрафувати можна лише M будівель. Окрім того, штрафувати можна лише будівлі, що йдуть послідовно. Будівлі штрафуються за кожен метр висоти. Так за будівлю вистою 50 метрів необхідно буде сплатити 50 грошових одиниць. Дирекція міста вирішила отримати найбільш можливе сумарне значення даного штрафу. Допоможіть дирекції знайти, скільки грошових одиниць штрафу вони зможуть отримати.\r\n<br><b>Вхідні дані</b>\r\n<br>У першому рядку вказані два числа: N (1 <= N <= 262144) – загальна кількість будівель та M (1 <= M <= N) – кількість послідовно-розміщених будівель, що будуть оштрафовані. У наступному рядку вказані висоти будівель по черзі їх розміщення через пробіл: A[0] A[1] … A[N] . (1 <= A[i] <= 1000).\r\n<br><b>Вихідні дані</b>\r\n<br>Виведіть єдине число: максимально можливе значення штрафу будівель.\r\n', '8 6 \r\n<br>880 466 891 627 266 552 473 <br>688\r\n', '3682\r\n', '8 6 \r\n880 466 891 627 266 552 473 688\r\n', '3682\r\n', 1, 1),
(12, 'Тунель', 'Одна сім’я вирішила вирушити у подорож на своєму новому електрокарі. Основна частина даної подорожі складає поїздку у довгому тунелі під океаном. Через деякий час після в’їзду до тунелю вони помітили, що батарея електрокару недостатньо заряджена для даної поїздки і необхідно витратити ще T секунд часу на світлі для отримання достатнього заряду через сонячні батареї. Тунель є недостатньо прозорим, щоб електрокар міг заряджатись. Винятком є лише деякі вікна, що знаходяться попереду електрокару. Завдяки мапі тунелю відомо, через скільки метрів почнеться вікно, і через скільки метрів воно закінчиться. Усі вимірювання проводяться від початкового положення електрокару (і початку вікна, і кінця). Вікна пропускають лише однонапрямлені промені світла.\r\nТак як електрокар був взятий на прокат, можливість змінювати швидкість по ходу подорожі відсутня, і буде залишатися сталою протягом усієї подорожі. Допоможіть сім’ї визначити, з якою максимальною швидкістю мав би їхати електрокар, щоб отримати достатньо заряду на усю подорож. Витратами заряду на проміжку з вікнами нехтувати.\r\n<br><b>Вхідні дані</b>\r\n<br>У першому рядку задано два числа: T (1 <= T <= 1000) – необхідний час для зарядження електрокару, та N (1 <= N <= 100) – кількість вікон у тунелі. У наступних N рядках описані краї вікон – x1 (через скільки метрів поїздки вікно почнеться) та x2 (через скільки метрів поїздки вікно закінчиться). Усі значення x лежать у межах (0 <= x <= 65536).\r\n<br><b>Вихідні дані</b>\r\n<br>У єдиному рядку вивести максимальну швидкість руху електрокару (у м/с), з якою він має рухатись щоб отримати достатньо заряду для усієї подорожі. Значення вивести з точністю до трьох знаків після коми.\r\n', '115 1 \r\n<br>516 1218\r\n', '6.104\r\n', '115 1 \r\n516 1218\r\n', '6.104\r\n', 1, 1),
(13, 'Відрізок та кола', 'На площині задано систему концентричних кіл, центри яких знаходяться на початку координат, а радіуси – 1, 2, 3, … . Також, на площині дано відрізок, кінці якого знаходяться у точках (x1, y1) та (x2, y2).\r\nНеобхідно знайти число спільних точок цього відрізка та вказаної системи кіл.\r\n<br><b>Вхідні дані</b>\r\n<br>Тест містить чотири цілих числа x1, y1, x2 та y2. Ці числа не більші за 103 за модулем. \r\n<br><b>Вихідні дані</b>\r\n<br>Виведіть одне число – кількість спільних точок.\r\n', '1 1 2 1\r\n\n||\n1 2 2 1\r\n', '1\r\n\n||\n0\r\n', '1 1 2 1\r\n\n||\n1 2 2 1\r\n\n||\n3 4 4 3\r\n\n||\n0 2 0 5\r\n\n||\n-5 -5 5 5\r\n', '1\r\n\n||\n0\r\n\n||\n2\r\n\n||\n4\r\n\n||\n14\r\n', 1, 1),
(14, 'Обернена матриця', 'Дано квадратну матрицю А n × n, визначення її оберненої матриці - B = A−1 – це матриця, що задовольняє рівність AB = I, де B та I  - матриці n×n, при чому І – одинична матриця. Для цієї задачі ви маєте розробити програму, яка б знаходила матриці, обернені до будь-якої матриці 2×2.\r\n<br><b>Вхід</b>\r\n<br>Кожен тест міститиме два рядки. Кожен рядок має два 32-bit signed числа; числа, подані у порядку a, b, c, d показують значення початкової матриці A =a b c d.\r\n<br><b>Вихід</b>\r\n<br>Виведіть номер тесту та два рядки, що містять обернену до даної матрицю.\r\n', '1 0 \r\n<br>0 1', '1 0 \r\n<br>0 1 ', '1 0 \r\n0 1 \n||\n30 29 \r\n1 1\r\n\n||\n-7 -16 \r\n4 9\r\n', '1 0 \r\n0 1\n||\n1 -29 \r\n-1 30 \n||\n9 16 \r\n-4 -7\r\n', 5, 1),
(15, 'Окружність Серпинського', 'Трикутник, який є набором нескінченної кількості точок, що можуть бути сконструйовані наступним чином:\r\n1.	Початкова форма є трикутником.\r\n2.	Скоротити Поточну форму до половини її розмірів (по висоті та ширині) та зробити дві її копії (всього вже три копії).\r\n3.	Впорядкувати ці три копії так, щоб кожна доторкалася до двох інших кутами. Встановіть поточну фігуру так, щоб вона була об”єднанням цих трьох.\r\n4.	Повторити крок 2.\r\nОскільки ітерації прямують до нескінченності, цей процес створює нескінченну кількість точок. Якщо початковий трикутник має окружність 3, яка сума всіх окружностей трикутників на даній ітерації? Напишіть програму для визначення не точного кола, а кількості десяткових знаків, необхідних для того, щоб показати цілу частину числа. Тобто, знайдіть таке число серед десяткових цифр, що відповідатиме найбільшому цілому числу, що не більше за найбільшу окружність.\r\n<br><b>Вхід</b>\r\n<br>Кожен тест міститиме невід’ємне ціле число 0 ≤ n ≤ 10,000, що визначає кількість ітерацій.\r\n<br><b>Вихід</b>\r\n<br>Виведіть номер тесту та число десяткових знаків необхідних для представлення цілої частини окружності для заданої кількості ітерацій.\r\n', '0\r\n\n||\n1\r\n\n||\n5\r\n', '1\r\n\n||\n1\r\n\n||\n2\r\n', '0\r\n\n||\n1\r\n\n||\n5\r\n\n||\n10\r\n\n||\n100\r\n', '1\r\n\n||\n1\r\n\n||\n2\r\n\n||\n3\r\n\n||\n19\r\n', 1, 1),
(17, 'Найкоротший шлях польоту', 'Комерційні польоти більш-менш безпечні (згідно з кількістю смертей на пасажир-кілометр, лише політ на Місяць безпечніший). Все ж таки залишаються причини зробити польоти більш безпечними. \r\n<br>Існує так зване правило 60-ти хвилин. Кожен двомоторний літак має завжди знаходитись у 60 хвилинах польоту від будь-якого аеропорту. Є ще багато правил, проте всі вони засновані на принципі обмеження максимально можливого часу знаходження від певного аеропорту. \r\n<br>У цій задачі ми порахуємо найкоротшу політ між двома аеропортами, дотримуючись деякого правила щодо максимально дозволеної відстані та часу, що згадувалось вище. Кожен шлях польоту має залишатися в межах трьох кіл. Таким чином, літак, що летить з другого аеропорту до третього має відхилитися у маршруті у регіон навколо першого аеропорту. Врахуйте, що літак не обов’язково має залітати до першого аеропорту.\r\n<br>Задача стає ще обмеженішою, оскільки літак мають обмежену кількість палива. Тому для довгих польотів, він має зробити якусь зупинку для дозаправки. Таким чином, в залежності від кількості доступного палива, літак, що йде від 2 до 3 аеропорту, має зробити зупинку в аеропорті 1.\r\nМи зробимо наступні припущення:\r\n<br>1. Поверхня Землі – сфера радіуса 6370 км.\r\n<br>2. Витрати часу та палива пропорційні до пройденої відстані.\r\n<br>3. Різниця у відстанях спричинена польотами літаків на різних висотах.\r\n<br>4. Літак може робити зупинки для дозаправки стільки разів, скільки це необхідно, (кожного разу набираючи повний бак).\r\n<br><b>Вхідні</b>\r\n<br>Перший рядок – два числа N та R, де 2 ≤ N ≤ 25 – це кількість аеропортів та 1 ≤ R ≤ 10000 – максимальна дозволена дальність польоту ( у км ) з найближчого аеропорту. Кожен із наступних  N рядків містить два цілих числа φ, θ таких, що 0 ≤ φ < 360 та −90 ≤ θ ≤ 90, довгота та широта положення аеропорту, у градусах. Аеропорти нумеруються з 1. Жодні два аеропорти не знаходяться на одній позиції. Наступний рядок – це число Q таке, що 1 ≤ Q ≤ 100. Кожен із наступних Q рядків включає три цілих числа s, t, c таких, що 1 ≤ s,t ≤ N, s 6= t, та 1 ≤ c ≤ 50000, які показують, що літак вилітає з аеропорту s до аеропорту t з ємністю палива, яка відповідає кількості кілометрів с. \r\n<br><b>Вихід</b>\r\n<br>Виведіть номер тесту та для кожного з них – довжину найкоротшого польоту між аеропортами s та t, відповідно до кількості палива. Вкажіть довжину з точністю до троьох знаків після коми. Якщо неможливо порахувати відстань – виведіть impossible.\r\n', '7 6 \r\n<br>2 0 1 1 \r\n<br>0 0 0 2 \r\n<br>1 0 4 3 \r\n<br>3 0 4 3 \r\n<br>5 0 1 1 \r\n<br>3 0 2 0 \r\n<br>5 0 3 0 \r\n<br>1 2 \r\n<br>1 3 \r\n<br>3 4 \r\n<br>4 7 \r\n<br>5 7 \r\n<br>6 7\r\n', '4.0000\r\n', '7 6 \r\n2 0 1 1 \r\n0 0 0 2 \r\n1 0 4 3 \r\n3 0 4 3 \r\n5 0 1 1 \r\n3 0 2 0 \r\n5 0 3 0 \r\n1 2 \r\n1 3 \r\n3 4 \r\n4 7 \r\n5 7 \r\n6 7\r\n\n||\n4 1 \r\n2 0 0 0 \r\n3 0 1 0 \r\n4 1 0 1 \r\n5 1 1 1 \r\n1 2\r\n', '4.0000\r\n\n||\nimpossible\r\n', 2, 1),
(18, 'Мінімальна вартість потоку', 'Ви наймані для конструювання транспортної системи передачі води між двома точками на старій фабриці, що використовує деякі існуючі компоненти старого водопроводу. Старі компоненти складаються з труб з переходами з піску. Якщо вода потрапить в один з таких переходів, вона заллє відкриту частину та врешті-решт всю будівлю фабрики. \r\n<br>Ви можете виправити ситуацію, встановивши нові труби між відкритими частинами та поставити штекери (затички), щоб закрити всі необхідні дірки. Вартість встановлення нової труби пропорційна відстані між центрами двох переходів, які з’єднує труба. Вартість встановлення штекера – 0.5. Ви не турбуєтеся про ті відкриті частини, куди вода ніколи не потрапить. \r\n<br>Два переходи – особливі. Один – джерело – це точка, куди вода подаватиметься перед подачею до інших пунктів (тобто початкова точка). Інший – призначення – це точка, куди необхідно доставити воду. Після того, як усі затички та труби встановлено, вода буде подаватися з достатнім тиском для того, щоб дістатися місця призначення (за відсутності витоків). \r\n<br>Вам дозволено обирати тиск, який не змінюватиметься впродовж роботи системи.  Ваше завдання – знайти найдешевший шлях подачі води від джерела до місця призначення, щоб не затопити приміщення фабрики.\r\n<br><b>Вхід</b>\r\n<br>Перший рядок містить два цілих числа N та M, де N (2 ≤ N ≤ 400) – це кількість переходів у будівлі та M (0 ≤ M ≤ 50000) – кількість існуючих труб, що використовуються. \r\n<br>У наступних N рядках міститься 4 числа xi, yi, zi, та ki таких, що −10000 ≤ xi,yi,zi ≤ 10000 та 0 ≤ ki ≤ 400, i = 1,2,...,N. і-й рядок описує перехід і: (xi,yi,zi) – це положення  переходу, де z – вертикальна вісь; ki визначає кількість відкритих частин у переході. Кожен наступний М-й рядок містить два цілих числа aj та bj таких, що 1 ≤ aj < bj ≤ N.   \r\n<br>j-й рядок показує, що j з’єднує переходи aj та bj. Не більше, ніж одна труба з’ єднує пару переходів, жодні два переходи не розташовані на одному місці з однаковими координатами. \r\n<br>Джерело – перехід 1, пункт призначення – N.\r\n<br><b>Вихід</b>\r\n<br>Виведіть номер тесту, далі, якщо нові труби та затички можуть бути використані для побудови нової системи, покажіть найменшу ціну з’єднання джерела переходу та переходу до місця призначення. \r\n<br>Якщо це неможливо, виведіть impossible.\r\n', '7 6 \r\n<br>2 0 1 1 \r\n<br>0 0 0 2 \r\n<br>1 0 4 3 \r\n<br>3 0 4 3 \r\n<br>5 0 1 1 \r\n<br>3 0 2 0 \r\n<br>5 0 3 0 \r\n<br>1 2 \r\n<br>1 3 \r\n<br>3 4 \r\n<br>4 7 \r\n<br>5 7 \r\n<br>6 7 ', '4.0000', '7 6 \r\n2 0 1 1 \r\n0 0 0 2 \r\n1 0 4 3 \r\n3 0 4 3 \r\n5 0 1 1 \r\n3 0 2 0 \r\n5 0 3 0 \r\n1 2 \r\n1 3 \r\n3 4 \r\n4 7 \r\n5 7 \r\n6 7 \n||\n4 1 \r\n2 0 0 0 \r\n3 0 1 0 \r\n4 1 0 1 \r\n5 1 1 1 \r\n1 2', '4.0000\n||\nimpossible', 4, 1),
(21, 'Додати чи Помножити', 'Комп”ютерна компанія пропонує дуже швидкий юніт для потреб користувачів. Процесор а-С-м сім’ї (наприклад, 1-С-2, 5-С-3)  має такі інструкції: додавання та множення. (А – додає, М - множить). Процесор отримує ціле число, виконує низку команд та видає результат. Наприклад, 1-С-2 процесор виконує програму АААМ з двома цілими числами і видає десять (обчислення такі: 2 → 3 → 4 → 5 → 10), в той час як 5-С-3 процесор з такою ж програмою видає результат 51 (обчислення такі: 2 → 7 → 12 → 17 → 51). Ви маєте закодувати а-С-м процесор, якщо вам дано лише  p, q, r, таs і такі умови:\r\n<br>\r\n1.	Вхідні дані – число між р та q.\r\n<br>\r\n2.	Вихідні дані мають бути між r та s.\r\n<br>\r\nСкладіть найкоротшу програму а-С-м.\r\n<br>\r\n<b>Вхідні дані</b>\r\n<br>\r\nВхідні дані включають у себе декілька тестів. Кожен випадок – рядок із 6 цілих чисел, які описані вище. Останній тест – всі числа – нулі.\r\n<br>\r\n<b>Вихідні дані</b>\r\n<br>\r\nДля кожного випадку покажіть його порядковий номер. Виведіть слово “empty” якщо програма не міститиме жодних операторів. Покажіть “impossible”, якщо неможливо виконати програму. Виведіть n операцій А та необхідну кількість операцій  типу М для досягнення необхідного результату.  ', '1 2 2 3 10 20\r\n\n||\n1 3 2 3 22 33\r\n', '1A 2M\r\n\n||\n1M 2A 1M\r\n', '', '', 1, 1),
(23, 'Прелюдії', 'Фредерик Шопен – польський композитор. Роки життя: 1810-1839. Відомими є його прелюдії, написані для фортепіано. На уявному фортепіано всього є 24 клавіші (взагалі тут 12 нот, але кожна нота має мінорну і мажорну тональність). \r\n<br>Ці 12 нот:\r\n<br>1   2   3   4   5   6   7   8   9   10   11   12\r\n<br>A A] = B[ B C C] = D[ D D] = E[ E F F] = G[ G G] = A[\r\n,br>П’ять нот з цього набору мають однакові назви (адже всього існує 7 нот). Вони позначені вище за допомогою знака «=» (наприклад, C] = D[ означає, що нота має дві назви - C] та D[). Тому існує 17 можливих назв для нот, але лише 12 з них насправді позначають ноти. Програючи одну з нот можна визначити її тональність (мажор чи мінор). Це дає 34 можливих варіанти, тоді як вірні лише 24. \r\n<br>В своїх уявних прелюдіях Шопен використав всі ці ноти, окрім тих 10, що мають однакові назви, але не відрізняються від інших.\r\n<br>A[ minor A] major A] minor C] major D[ minor D] major D] minor G[ major G[ minor G] major\r\n<br>Напишіть програму, що на задану ноту виведе її альтернативну назву (якщо вона існує) або повідомлення про те, що нота є унікальною.\r\n<br><b>Вхід:</b>\r\n<br>Кожен тест має на вхід одну лінію в форматі «нота тональність», де нота може мати одну з 17 назв, а тональність одну з двох. Назви нот будуть записані у верхньому регістрі, а тональності як # для мажору і b для мінору.\r\n<br><b>Вихід:</b>\r\n<br>Для кожного випадку вивести номер, за яким слідує альтернативна назва ноти або, в іншому випадку, слово UNIQUE.\r\n', 'Ab minor', 'G# minor', 'Ab minor\n||\nD# major \n||\nG minor\r\n', 'G# minor\n||\nEb major \n||\nUNIQUE', 3, 1),
(24, 'Астероїди', 'Надворі 2112 рік, людство опанувало Сонячну систему. Космічний рейнджер Корпс встановив \r\nбазу на кожному астероїді, навіть на тих, що досі не заселені. \r\n<br>Ваша робота, як члена Міністерства Зв’язку Астероїдів, полягає у налаштуванні баз таким чином, щоб кожні з них могли мати якнаймога дешевший зв’язок одна з іншою. Ви можете прокладувати зв’язок з однієї бази в іншу.  <br>Потрібно знайти таку мінімальну кількість цих зв’язків таких, щоб кожна база мала зв’язок з усіма іншими базами (не обов’язково прямий). Вартість кожного зв’язку прямо пропорційна відстані між двома базами, що з’єднані, так що ця проблема не здається важкою.\r\n<br>Але є одна проблемка. Астероїди рухаються. І якщо зараз астероїди знаходяться поруч один від одного, це не означає, що так буде завжди. Тому зв’язок іноді треба буде змінювати, щоб досягати найдешевшого результату зв’язку. Але зміна зв’язків теж займає деякий час, та ваші фінанси не безкінечні.\r\n<br>Є два припущення, що можуть облегшити роботу. Кожен астероїд представлений точкою, рухається прямолінійно і з постійною швидкістю. Ніякі два астероїди не можуть перетинатися. Також, кожна система, що є оптимальною за час t >= 0 буде унікально оптимальною для будь-якого часу s такого, що t < s < t + 10e-6. Початкові умови системи унікальні.\r\n<br><b>Вхід:</b>\r\n<br>Кожний тестовий файл починається з рядка, що містить ціле число від 2 до 50, яке позначає кількість існуючих баз. Потім ідуть n ліній, кожна з яких містить 6 цілих чисел – координати астероїда (-150 < x,y,z < 150) та їх швидкості у трьох координатах (-100, vx, vy, vz < 100).\r\n<br><b>Вихід:</b>\r\n<br>Вивести один рядок, що містить номер випадку та число, що позначає те, скільки разів система мусть бути перебудована.\r\n', '3 \r\n<br>0 0 0 0 0 0 \r\n<br>5 0 0 0 0 0 \r\n<br>10 1 0 -1 0 0 \r\n', '3\r\n', '3 \r\n0 0 0 0 0 0 \r\n5 0 0 0 0 0 \r\n10 1 0 -1 0 0 \r\n\n||\n4 \r\n0 0 0 1 0 0 \r\n0 1 0 0 -1 0 \r\n1 1 1 3 1 1 \r\n-1 -1 2 1 -1 -1\r\n', '3\r\n\n||\n3\r\n', 2, 1),
(25, 'Обмежена переписка', 'Польський математик Еміль відправив просту задачу своєму британському другу Алану. Алан відповів, що від не має стільки часу на розв’язання нерозв’язних завдань. Еміль трохи змінив цю задачу (полегшив її) та зновy відправив Алану. Тоді Алан склав її.\r\n<br>Оригінальна задача, яку вперше відправив Еміль. \r\n<br><br>Є послідовність пар (а1, б1), (а2, б2),.. така, що в ній можна знайти непусту послідовність s1…sm, для якої стверджується \r\n<br>as1as2 ...asm = bs1bs2 ...bs, де as1as2 ... позначають конкатенацію рядків. Змінена задача містила таку умову: <br>для всіх i 6= j, si 6= sj.\r\n<br>Чи зможете ви розв’язати цю задачу?\r\n<br><b>Вхід:</b>\r\n<br>Кожен тестовий файл складається зі строки, що містить ціле число k від 1 до 11. Потім йдуть k строк, кожна з яких містить дві строки, відділені пробілом, що є парою. Кожна строка містить максимум 100 символів.\r\n<br><b>Вихід:</b>\r\n<br>Вивести номер випадку, після якого йде знайдена послідовність або IMPOSSIBLE, якщо її не існує. Якщо послідовностей декілька, вивести найкоротшу. Якщо найкоротші однакового розміру, вивести першу з них у лексикографічному порядку.\r\n', '5 \r\n<br>are yo \r\n<br>you u \r\n<br>how nhoware \r\n<br>alan arala \r\n<br>dear de', 'dearalanhowareyou', '5 \r\nare yo \r\nyou u \r\nhow nhoware \r\nalan arala \r\ndear de \n||\n8 \r\ni ie \r\ning ding \r\nresp orres \r\nond pon \r\noyc y \r\nhello hi \r\nenj njo \r\nor c\n||\n3 \r\nefgh efgh \r\nd cd \r\nabc ab \n||\n3 \r\na ab \r\nb bb \r\nc cc\r\n', 'dearalanhowareyou\n||\nienjoycorresponding\n||\nabcd\n||\nIMPOSSIBLE\r\n', 3, 1),
(26, 'Порахувати зірки', 'Рівень астрономічних знань людства значно підвищився з розвитком комп’ютерних технологій. Алгоритми можуть автоматично розпізнавати картини нічного неба…\r\n<br><br>Напишіть програму, що аналізує картинку з зоряним небом і визначає кількість зірок на ньому. \r\n<br>Небо представлене множною рисок та дієзів, де риски – частинки зорі.\r\n<br><br><b>Вхід:</b>\r\n<br>Кожний тестовий файл складається з двох чисел – кількості рядків та кількості пікселів у рядку.\r\n<br><b>Вихід:</b>\r\n<br>Вивести кількість зірок у небі.\r\n', '10 20 \r\n<br>#################---\r\n<br>##-###############-#--\r\n<br>################ ##-\r\n<br>################# <br>########---######### <br>#######-----######## <br>########---######### <br>##################-\r\n<br>#################--\r\n<br>##################-# ', '4', '10 20 #################--##-###############-#---################ ##-################# ########---######### #######-----######## ########---######### ##################-#################--##################-# \n||\n3 10 \r\n#-######## \r\n---------#\r\n-########\r\n', '4\n||\n1', 3, 1),
(27, 'Циклічний рядок', 'Рядок S був записаний багато разів поспіль, після чого з нового рядка взяли підрядок і дали вам. \r\n<br>Ваша задача – визначити мінімально можливу довжину початкового рядка S.\r\n<br><br><b>Вхід</b>\r\n<br>Записаний рядок, довжиною не більше 50000 символів (лише латинські).\r\n<br><b>Вихід</b>\r\n<br>Виведіть відповідь на задачу.\r\n', 'abababa\r\n', '2\r\n', 'abababa\r\n\n||\nabcccaabc\r\n\n||\naaaabaa\r\n\n||\nabcaabcaab\r\n\n||\naaaaaaa\r\n\n||\naaabcaaabcdaaab\r\n', '2\r\n\n||\n6\r\n\n||\n5\r\n\n||\n4\r\n\n||\n1\r\n\n||\n11\r\n', 3, 1),
(28, 'Натуральний ряд чисел', 'Натуральні чила записані у рядок без роздільників. \r\n<br>Початок рядку має вигляд <br>123456789101112131415161718192021… .\r\n<br>Необхідно написати програму, яка визначатиме перше входження десяткового запису заданого числа N у цьому рядку.\r\n<br><br><b>Вхід</b>\r\n<br>Міститься одне ціле число N (1 <= N <= 104). \r\n<br><b>Вихід</b>\r\n<br>Виведіть єдине число – позицію, починаючи з якої у рядку записано перше входження даного числа. Нумерація – від 1.\r\n', '45\r\n\n||\n101', '4\r\n\n||\n10', '45\r\n\n||\n101\r\n\n||\n142\r\n\n||\n41\n||\n44\n||\n31\n||\n100\n||\n1213\n||\n213\n||\n54\n||\n91\n||\n97', '4\r\n\n||\n10\r\n\n||\n73\r\n\n||\n19\n||\n78\n||\n17\n||\n190\n||\n14\n||\n15\n||\n81\n||\n9\n||\n129', 1, 1),
(29, 'Видобуток власного бізнесу', 'Джон Дігер – власник шахти. Шахта складається з серії тунелів, які включають різні великі вузли. \r\n<br>На відміну від деяких власників, Дігер піклується про добробут своїх працівників та турбується про розташування шахти, а саме про те, що  там може бути такий перехід, що у разі колапсу він відріже працівник однієї секції від інших. \r\n<br>Щоб протидіяти цьому, він хоче встановити спеціальні вали на поверхні. Він може встановити один вал на кожний перехід, але Дігер не турбується про своїх працівників так сильно, оскільки хоче поставити мінімальну кількість валів так, щоб у разу колапсу всі працівники, які будуть у цей час у переході мали вихід до валу. \r\n<br><br>Напишіть програму для обрахунку найменшої кількості валів та загальну кількість шляхів, на яких ці вали могли б розташовуватися. \r\n<br><br><b>Вхід</b>\r\n<br>Перший рядок містить додатне ціле число N (N ≤ 5•104), яке визначає кількість тунелів у шахті. \r\n<br>Далі йдуть N рядків, кожен із яких містить два цілих числа s та t, де s та t – номери переходів. Переходи пронумеровані починаючи від 1. \r\n<br>Кожна пара переходів з’єднана одним тунелем. Кожний набір тунелів шахти утворює один з‘єднаний юніт (це означає, що ви можете дістатися з одного переходу до будь-якого іншого). \r\n<br>Останній тест – один нуль.\r\n<br><b>Вихід</b>\r\n<br>Для кожного тесту покажіть його номер і виведіть мінімальну кількість валів, необхідних для функціонування необхідної системи та загальну кількість шляхів, де ці вали можуть бути встановлені.\r\n\r\n', '9 \r\n<br>1 3 \r\n<br>4 1 \r\n<br>3 5 \r\n<br>1 2 \r\n<br>2 6 \r\n<br>1 5 \r\n<br>6 3 \r\n<br>1 6 \r\n<br>3 2', '2 4', '9 \r\n1 3 \r\n4 1 \r\n3 5 \r\n1 2 \r\n2 6 \r\n1 5 \r\n6 3 \r\n1 6 \r\n3 2\n||\n6 \r\n1 2 \r\n1 3 \r\n2 4 \r\n2 5 \r\n3 6 \r\n3 7 ', '2 4\n||\n4 1', 2, 1),
(30, 'Автобусний тур', 'Уявіть, що ви турист у Варшаві, що забронював автобусний тур, аби побачити дивовижні пам’ятки за містом. Автобус їздить доволі довго, оскільки він забирає всіх туристів з різних готелів по всій Варшаві. Далі він їде до пам’яток, а далі розвозить туристів по готелях. Ваш готель завжди перший, коли ви їдете до пам’яток і останній, коли вас відвозять назад. Це означає, що ви вимушені двічі об’їжджати місто, що вам не цікаво. \r\n<br>Ми зробимо таку програму, яка б дозволила власникам автобусної компанії розробляти маршрут більш справедливо та чесно стосовно кожного туриста.\r\n<br>Є початкова точка (штаб-квартира компанії), h готелів, які необхідно відвідати та a місць призначень (пам”ятки). \r\n<br>Ми маємо знайти маршрут, що йде від штаб-квартири через усі готелі, їде до місця призначення, їде назад також через всі готелі (можливо в іншому порядку) та повертається до штаб-квартири. Щоб гарантувати кожному туристу, що вони не їхатимуть повне через усе місто двічі, ми кажемо, що кожен готель, який відвідали серед перших bh/2c готелів на шляху до пам’яток має бути відвіданим стільки ж разів на шляху назад. Наша задача – зробити автобусний тур якомога коротшим. \r\n<br><b>Вхід</b>\r\n<br>Перший рядок кожного тесту містить два цілих числа \r\n<br>3 ≤ n ≤ 20 та 2 ≤ m, де n – кількість місць призначень (готелів, штаб-квартир, пам’яток) та m – кількість таких місць призначень, між якими автобус може подорожувати. \r\n<br>n різних місць призначень нумеруються від 0 до n-1, де 0 – це штаб-квартира, від 1 до n-2 – готелі, n-1 – пам’ятки. \r\n<br>Вважатимемо, що існує не більше одного направленого шляху між місцями призначення, а також що можливо подорожувати з будь-якого місця в будь-яке інше (але необов’язково направлено). \r\n<br>Наступні m рядків містять три цілих числа u, v,та t такі, що 0 ≤ u, v ≤ n−1,  u 6= v,  1 ≤ t ≤ 3600, які визначають, що автобус може їхати прямо між пунктами призначення u та v за t секунд (у будь-якому напрямку).\r\n<br><b>Вихід</b>\r\n<br>Виведіть номер тесту та час найкоротшого можливого автобусного туру ( у секундах ).\r\n', '5 4\r\n<br>0 1 10\r\n<br>1 2 20\r\n<br>2 3 30\r\n<br>3 4 40', '300', '4 6 \r\n0 1 1\r\n0 2 1\r\n0 3 1\r\n1 2 1\r\n1 3 1\r\n2 3 1\r\n\n||\n5 4\r\n0 1 10\r\n1 2 20\r\n2 3 30\r\n3 4 40', '6\n||\n300', 1, 1);
INSERT INTO `tasks` (`id`, `name`, `prob`, `example_in`, `example_out`, `test_in`, `test_out`, `topic`, `timelimit`) VALUES
(31, 'Фільтрація', 'Доброго ранку, Агенте W-12. \r\n<br>Ваша місія полягає у наступному. Ми фільтруємо дуже підступну Асоціацію Хаосу та Пустощів (Association of Chaos and Mischief (ACM)  ), щоб скинути їх командування. На жаль, вони, здається, готові до такого повороту подій, тому надали наказ своїм командним структурам зробити певний комплексний проект захисту, що зробить нашу фільтрацію трохи складною. \r\n<br><br>Командна структура ACM розділена на декілька областей. Для кожної пари області (регіону) А та В, чи А контролює В, чи В контролює А. Проте, цей контроль може бути циклічним, тобто може статися, що і А контролює В, і В контролює А. \r\n<br>Ми можемо відправити агента для фільтрації певного регіону, що дасть нам контроль над поточним регіоном та тим, що він контролює. Для успішної фільтрації АСМ ми маємо контролювати всі її області, інакше регіону, що не знаходяться під нашою владою розкриють нас і почнуть виробляти речі під маркою хаосу та пустощів. Ваша місія полягає у віднаходженні мінімальної кількості регіонів, які ми маємо контролювати для успішного завершення операції фільтрації. \r\n<br><br>Місія самознищиться через 5 годин. Щасти! \r\n<br><br><b>Вхід</b>\r\n<br>Перший рядок – містить одне число n – кількість регіонів АСМ (1 ≤ n ≤ 75). \r\n<br>Кожен наступний із n рядків містить бінарний рядок довжиною n, де і-й рядок = 1, якщо J контролює і та = 0, якщо ні (1 ≤ i,j ≤ n). \r\n<br>і-й символ і-того рядка це 0 та для і6 = j, або і-й символ J-того рядка це 1, або j-й символ і-того рядка це 1, але не одночасно.\r\n<br><b>Вихід</b>\r\n<br>Виведіть номер тесту та мінімальну кількість регіонів, що ми маємо контролювати для завершення місії АСМ. <br>Виведіть m чисел c1,...,cm у будь-якому порядку, що показуватимуть список регіонів для фільтрації (регіони нумеруються від 1 до n).\r\n', '2\r\n<br>00\r\n<br>10\n||\n3\r\n<br>010\r\n<br>001\r\n<br>100\r\n', '1 2\n||\n2 1 2', '2\r\n00\r\n10\n||\n3\r\n010\r\n001\r\n100\r\n\n||\n5\r\n01000\r\n00011\r\n11001\r\n10100\r\n10010', '1 2\n||\n2 1 2\n||\n2 2 3', 1, 1),
(32, 'Реверсивні дороги', 'Ви працюєте у місті одного напрямку. Міська влада постановила, що рух на дорогах відбувається лише в одному напрямку. Ви працюєте над пропозиціями нової дивізії та її транспортними мережами. \r\n<br><br>Єдина проблема, яку ви знайшли – це те, що неможливо дістатися до певних місць призначення з інших запропонованими дорогами. \r\n<br>Щоб прискорити оцінку наступних пропозицій, ви хочете написати програму, яка б обраховувала можливість дістатися до будь-якого місця призначення з іншого. Якщо пропозиція не діє, ваша програма визначатиме чи найлегший шлях виправити це, перевернувши напрямок однієї з доріг.\r\n<br><br><b>Вхід</b>\r\n<br>Кожен тест міститиме рядок із двох цілих чисел\r\n<br>1 ≤ m ≤ 50 та 0 ≤ n ≤ m(m−1)/2. M визначає кількість місць призначення у пропозиції, n визначає кількість доріг, що їх з”єднують. \r\n<br>Наступні n рядків включають a та b, де 0 ≤ a,b < m та а6=b. \r\n<br>Це означає, що існує шлях з а в b. Якщо є дорога з а у b, то не існує оберненого шляху. Не може бути також більше, ніж одна дорога між пунктами призначення.\r\n<br><b>Вихід</b>\r\n<br>Виведіть номер тесту, а також чи є пропозиція валідною, чи ні. \r\n<br>Якщо вона є такою, виведіть на екран valid, якщо ні, то перевірте, чи можна виправити ситуацію, перевернувши напрямок якоїсь дороги, якщо так – виведіть виправлений варіант поточної пропозиції.\r\n', '3 3\r\n<br>0 1\r\n<br>1 2\r\n<br>2 0\n||\n3 3\r\n<br>0 1\r\n<br>1 2\r\n<br>0 2', 'valid\n||\n0 2', '3 3\r\n0 1\r\n1 2\r\n2 0\n||\n3 3\r\n0 1\r\n1 2\r\n0 2\n||\n3 2\r\n1 2\r\n0 2\n||\n4 4\r\n0 1\r\n1 2\r\n2 3\r\n0 3', 'valid\n||\n0 2\n||\ninvalid\n||\n0 3', 1, 1),
(33, 'Польський запис', 'Існує певний вид запису математичних операцій та обрахунків у пам’яті комп’ютера – польський запис. \r\n<br>Це означає, що приклад 3 + 4 ∗ 7 записується з операторами перед числами, тобто  + 3 ∗ 4 7. Маємо три операції: додавання (+), віднімання (-), та множення (*).\r\n<br><br>Напишіть програму, яка би переробляла польський запис у нормальний та обраховувала значення отриманого виразу.\r\n<br><br><b>Вхід</b>\r\n<br>Кожен тест містить певний вираз – його польський запис. Кількість символів – до 2048.\r\n<br><b>Вихід</b>\r\n<br>Виведіть номер тесту та результат отриманого виразу.\r\n', '+ 3 4\r\n', '7\r\n', '+ 3 4\r\n\n||\n- x x\r\n\n||\n* - 6 + x -6 - - 9 6 * 0 c\r\n', '7\r\n\n||\n- x x\r\n\n||\n* - 6 + x -6 - 3 * 0 c\r\n', 6, 1),
(34, 'Лампочки', 'Маємо ряд із N ламп, які пронумеровані від 1 до N. <br>Спочатку жодна з них не горить. Далі відбуважться К послідовних лінійних інверсій цього ряда ламп. \n<br>Під лінійною інверсією мається на увазі інверсія кожної Р-ї лампи у ряді. \n<br>Наприклад, якщо Р=3, то відбудеться інверсія 3-ї, 6-ї, 9-ї і т.д. ламп.\n<br>Необхідно визначити скільки ламп, що горять, залишиться після реалізації всіх заданих лінійних інверсій?\n<br><br><b>Вхід</b>\n<br>У першому рядку – дано числа N та P  - число ламп та кількість інверсій. Другий рядок містить К цілих чисел Рі, що задають період даних інверсій (1 <= N <= 109, 1<=K<=100, 1 <= Pi <= 50).\n<br><b>Вихід</b>\n<br>Виведіть відповідь на задачу.\n', '20 3 <br>\r\n2 3 8\r\n\n||\n172 10 <br>\r\n19 2 7 13 40 23 16 1 45 9\r\n', '8\r\n\n||\n99\r\n', '172 10\r\n19 2 7 13 40 23 16 1 45 9\r\n\n||\n20 3\r\n2 3 8\r\n\n||\n12 1\r\n1\r\n\n||\n100 4\r\n20 12 3 19\r\n\n||\n6 1\r\n10\r\n\n||\n8 2\r\n1 3\r\n\n||\n140 3\r\n2 4 8\r\n\n||\n300 12\r\n1 4 2 30 24 12 63 97 3  80 11 44\r\n', '99\r\n\n||\n8\r\n\n||\n12\r\n\n||\n33\r\n\n||\n0\r\n\n||\n6\r\n\n||\n52\r\n\n||\n179\r\n', 1, 1),
(35, 'Прикольні пляшечки', 'Дорогою із Варшави, Джо побачила у магазині  незвичну скляну пляшку. Вона подумала, що можна було би зробити цікавий проект із нею, якщо використати таку пляшку для вимірювання кількості води, цікавість у тому, що маркування показувало би рівень води всередині пляшки. <br><br>Питанння у тому, де розміщувати таке маркування?\r\n<br>Вона помітила, що пляшка має форму поліному, між x = xlow та x = xhigh по осі іксів. Вона розміщена вертикально по центру пляшки. \r\n<br>Перший приклад вхідних даних містить звичайний поліном <br>4−0.25x, де xlow = 0 та xhigh = 12.  \r\n<br>Середина пляшки – коло радіусу 4, горлятко – коло радіусу 1. Висота пляшки – 12. Рівень рідин – до 25. \r\n<br>Дано поліном Р, xlow, xhigh та рівень рідин.\r\n<br><br><b>Вхід</b>\r\n<br>Кожен тест містить три рядки даних про пляшку:\r\n<br>1. Степінь поліному\r\n<br>2. a0, a1, ..., an, … - коефіцієнти поліному\r\n<br>3. xlow та xhigh \r\n<br><b>Вихід</b>\r\n<br>Для кожного тесту вкажіть номер випадку та рівень рідин у першому рядку. \r\n<br>У другому рядку покажіть зростання послідовності маркування пляшки, не більше за 8 кроків від дна пляшки.\r\n', '', '', '', '', 2, 1),
(36, 'Геліоцентричний', 'Копернік склав нову модель Сонячної Системи, в якій Земля – її центр. Відповідно до цього, Земля обертається навкооло сонця за 365 земних років, а Марс точно за 687. <br>Земля починає обертатися у день 0, завершує цикл – на 364-ому дні. \r\n<br>Марс рухається неперервно завжди 687 днів. Ми би хотіли знайти як багато пройде часу, поки вони одночасно не опиняться на дні 0. \r\n<br><br>Напишіть програму, щоб !!!!!!!!\r\n<br><br><b>Вхід</b>\r\n<br>Кожний тест містить два цілих числа 0 ≤ e < 365 and 0 ≤ m < 687. Вони показують у які дні Земля та Марс на відповідних орбітах.\r\n<br><b>Вихід</b>\r\n<br>Виведіть номер тесту та найменшу кількість днів до того, як планети будуть одночасно на відмітці день 0.\r\n', '', '', '', '', 2, 1),
(37, 'Мандельброт', 'Множина Мандельброта малюється на комплексній площині. Горизонтальна вісь показує реальну частину числа, а вертикальна – уявну. \r\n<br>Комплексне число - c = x + yi не належить множині Мандельброта, якщо zn+1 ← z2 n + c починається з z0 = 0. <br>Це означає, що limn→∞|zn| = ∞. Якщо умова не викнується, число належить множині. \r\n<br><br>Напишіть програму, яка обраховує чи дане число входить у множину Мандельброта за фіксовану кількість ітерацій. Тобто, чи є воно множиною Мандельброта чи ні? <br>Перевірте чи |zn| > 2 для будь-якого zn та, якщо це так, то послідовність входить у множину.\r\n<br><br><b>Вхід</b>\r\n<br>Кожен тест містить 2 цілих числа −3 ≤ x ≤ 3 and −3 ≤ y ≤ 3, та ціле число  0 ≤ r ≤ 10,000. \r\n<br>Значення с = x + yi, r – максимальна кількість ітерацій.\r\n<br><b>Вихід</b>\r\n<br>Для будь –якого випадку виведіть його номер та вкажіть IN, якщо число входить до необхідної множини та OUT – якщо ні.\r\n', '', '', '', '', 1, 1),
(38, 'Вежі влади', 'У цій задачі ми просто сортуватимемо числа. \r\n<br>Цікавість у тому, що числа будуть записані у вигляді <br>а^а1^…^аn, де 1 ≤ a1,a2,...,an ≤ 100 та 1 ≤ n ≤ 100.  \r\n<br><br><b>Вхідні</b>\r\n<br>Перший рядок міститиме М цілих чисел, 1 ≤ M ≤ 100. <br>Кожні наступні М рядків описують одне з М чисел. Числа записані з використанням символу (^) без пробілів.\r\n<br><b>Вихід</b>\r\n<br>Виведіть номер тесту та відсортовані цілі числа один за одним у рядочки, як в оригіналі.\r\n', '', '', '', '', 1, 1),
(39, 'Статистика', 'Дослідження часто пов”язані з використанням великих обсягів даних. Статистика описує всі такі дані. \r\n<br>Зазвичай дані виглядають так: X = (x1,x2,...,xn). <br>Бувають різні випадки обрахунків у статистиці, проте основні з них такі:\r\n<br><br>• min(X): найменше значення X \r\n<br>• max(X): найбільше значення X \r\n<br>• range(X): max(X)−min(X)\r\n<br><br>Напишіть програму, яка б аналізувала дані та виводила результат для кожного з цих критеріїв, описаних вище.\r\n<br><br><b>Вхід</b>\r\n<br>Кожний рядок міститиме число 1 ≤ n ≤ 30,\r\n<br> далі йтимуть n цілих чисел між -1,000,000 та 1,000,000.\r\n<br><b>Вихід</b>\r\n<br>Виведіть номер тесту та результати обрахунків у відповідному порядку.\r\n', '', '', '', '', 1, 1),
(40, 'Щохвилинні автобуси', 'На автобусну зупинку щохвилини приїжджає автобус одного з маршрутів. Диспетчерська служба зібрала дані за N хвилин – номери маршрутів кожного автобуса.\r\n<br>Необхідно визначити можливий час очікування для пасажира, що хоче поїхати визначеним маршрутом. Тобто у даній послідовності номерів потрібно знайти два найвіддаленіших сила, що рівні між собою. \r\n<br>Наприклад для послідовності \r\n<br>2, 11, 2, 2, 25, 11, 25, 11 \r\n<br>максимальний час очікування = 4 (для маршруту 11 ).\r\n<br><br><b>Вхід</b>\r\n<br>У першому рядку – число N (2 ≤ N ≤ 106). \r\n<br>У другому – N чисел – номери маршрутів. \r\n<br>Усі числа – натуральні та менше 100. Кожний номер зустрічається не менше 2 разів.\r\n<br><b>Вихід</b>\r\n<br>Виведіть відповідь задачі.\r\n', '8 <br>\r\n2 11 2 2 25 11 25 11\n||\n4 <br>\r\n23 23 41 41', '4\n||\n1', '8\n2 11 2 2 25 11 25 11\n||\n4\n23 23 41 41\n||\n15\n1 1 1 1 1 2 2 1 1 1 1 1 1 1 1\n||\n9\n2 31 2 4 5 31 5 4 2\n||\n4\n1 3 1 3\n||\n12\n1 2 3 4 4 3 2 1 2 2 2 4\n||\n2\n1 1\n||\n8\n2 30 56 30 56 30 30 2\n||\n6\n40 12 40 40 12 12', '4\n||\n1\n||\n3\n||\n6\n||\n2\n||\n7\n||\n1\n||\n7\n||\n3', 1, 1),
(41, 'Числа Фібоначі', 'Послідовність бітових рядків Фібоначчі визначається як<br>\r\n<img src = "http://77.47.239.14/cursach/res/fibonaci.png"><br>\r\n\r\nВраховуючи бітовий шаблон p і число n, як часто р зустрічається в <i>F(n)</i>?<br>\r\n<b><i>Вхідні дані</i></b><br>\r\nПерший рядок містить ціле число n (0 ≤ n ≤ 100). Другий рядок містить р. Р – непустий та має довжину 100000 символів.<br>\r\n<b><i>Вихідні дані</i></b><br>\r\nДля кожного випадку покажіть його номер та номер співпадіння р у <i>F(n)</i> ( менший за 263 ).', '6\r\n10\r\n', '5\r\n', '7\r\n10\r\n\n||\n6\r\n01\r\n\n||\n6\r\n101\r\n\n||\n96\r\n10110101101101\r\n', '8\r\n\n||\n4\r\n\n||\n4\r\n\n||\n7540113804746346428\r\n', 5, 1),
(42, 'Дивна лотерея', 'На честь успішного завершення першої чверті Петру та Вові подарували один лотерейний білет. Як завжди, хлопці серйозно не сприйняли такий подарунок. Проте, пізніше вони дізналися зі ЗМІ, що номер їх білету – виграшний.<br>\r\nПісля довгих хвилин радості хлопці пішли дізнаватися суму виграшу , але виявилося, що дізнатися про це не так же і просто. Річ у тім, що сума виграшу частково визначається самим власником наступним чином. На оберненій стороні білету є певна секція, де можна стерти захисне покриття та побачити ціле число N. Після цього кожний власник білету повинен закреслити рівно по одній цифрі числа N, отримане число і є сумою виграшу.<br>\r\nНижче наведено приклад з числом N = 995051.<br>\r\n<img src = "http://77.47.239.14/cursach/res/lotery.png"><br>\r\nМаксимальне число, яке може бути отримане з цього числа – 9955. Допоможіть Петру та Вові у цій дуже актуальній для них задачі.<br>\r\n<b><i>Вхід</i></b><br>\r\nУ єдиному рядку містить число N (100 ≤ N < 10250).<br>\r\n<b><i>Вихід</i></b><br>\r\nВиведіть єдине число – максимальне значення, яке може бути отримане з N шляхом вилучення  з нього рівно двох цифр.', '995051\r\n', '9955\r\n', '995051\r\n\n||\n102\r\n', '9955\r\n\n||\n2\r\n', 3, 1),
(43, 'Живопис', 'Дана матриця NxM з клітинами, пофарбованими або в чорний, або в білий кольори.<br>\r\nW - ціна перефарбовування чорного квадрата в білий, B - білого в чорний.<br>\r\nПісля перефарбовування, між усіма сусідніми квадратами різних кольорів потрібно провести сіру лінію, ціною G.\r\nТреба так отпимального перефарбувати матрицю (або нічого не робити), що б витратити мінімальну суму.<br>\r\n<b>Вхідні дані </b> <br>\r\nРозмір матриці MxN та колір кожної клітинки ( 1 - білий 2 - чорний) в наступному рядку W, B та G - вартості перефарбування <br>\r\n<b>Вихідні дані </b><br>\r\nОдне число - найменша можлива ціна перефарбування', '2 2<br>\r\n1 1 1 1<br>\r\n2 2 1\r\n\n||\n2 2<br>\r\n1 2 1 2<br>\r\n1 2 5\r\n', '0\r\n\n||\n2\r\n', '2 2\r\n1 1 1 1\r\n2 2 1\r\n\n||\n2 2\r\n1 2 1 2\r\n1 2 5\r\n', '0\r\n\n||\n2\r\n', 4, 1),
(44, 'Дорожній аукціон', 'Десь далеко від нас, на краю землі, є одна невелика, але красива країна WWW з багатющим історичним минулим. Люди, які населяють її, відомі всьому світу своєю добротою і гостинністю. Вся територія країни умовно поділена на райони. Кожен район складається з певної кількості міст, один з яких є районним центром.\r\n<br>\r\nДеякі пари міст даної держави з''єднані двосторонніми дорогами, причому відомо, що будь-який районний центр з''єднаний дорогами з усіма іншими містами району, а також не більше ніж з двома іншими районними центрами. Ніяка дорога не з''єднує два міста, які не є районними центрами. Дорога може з''єднувати два міста з різних районів тільки в тому випадку, якщо обидва вони є районними центрами. Між будь-якою парою міст може бути не більше однієї дороги. Дороги побудовані таким чином, що по них можна доїхати з будь-якого міста в будь-який інший.\r\n<br>\r\nІсторично склалося, що право на володіння всіма дорогами до недавніх пір належали одній відомій компанії «Автодор». У зв''язку з цим в конституційний суд був поданий антимонопольний позов, який був задоволений - тепер компанії належить продати частину своїх володінь. Економісти компанії визначили для кожної дороги її вартість.\r\n<br>\r\nОдна маленька, небагата, але горда фірма «КурсІнвест», в якій Ви працюєте фінансовим директором, захотіла викупити частину доріг, а саме, К з них. Причому необхідно, щоб для будь-яких двох міст, до яких примикає хоча б одна з викуплених До доріг, існувало не мене одного з''єднує їх шляху, що складається тільки з придбаних доріг. Вам, як фінансовому директору, було доручено знайти економічно вигідне рішення. Рішення будемо називати економічно вигідним, якщо грошова сума, витрачена на придбання доріг, є мінімальною.\r\n<br>\r\n<b>Вхідні дані</b><br>\r\n\r\nУ першому рядку знаходяться три цілих числа N (3 ≤ N ≤ 2000), М і К (1 ≤ K < M ≤ 10^5), де N - загальна кількість міст, M - загальна кількість доріг, K - кількість доріг, яке необхідно придбати.\r\n\r\nДалі слід M рядків, у кожному з яких записані три цілих числа Ai, Bi і Ci, де Ai і Bi - номери міст, які з''єднані дорогою (1 ≤ Ai, Bi ≤ N, Аi ≠ Бі), а Ci - вартість дороги (1 ≤ Cі ≤ 10^6). Всі числа у рядках розділені одиночними пробілами.\r\n<br>\r\n<b>Вихідні дані</b>\r\n<br>\r\nК рядків, кожен з яких має містити одне число - номер придбаної дороги. Дороги нумеруються в порядку їх введення починаючи з одиниці. Якщо рішень декілька, то виведіть будь-яке з них.', '9 8 4<br>\r\n8 9 2<br>\r\n5 1 10<br>\r\n3 8 11<br>\r\n2 5 7<br>\r\n8 7 8<br>\r\n5 6 12<br>\r\n4 7 9<br>\r\n3 5 5\r\n', '4<br>\r\n1<br>\r\n8<br>\r\n3\r\n', '9 8 4\r\n8 9 2\r\n5 1 10\r\n3 8 11\r\n2 5 7\r\n8 7 8\r\n5 6 12\r\n4 7 9\r\n3 5 5\r\n', '4\r\n1\r\n8\r\n3\r\n', 1, 1);

-- --------------------------------------------------------

--
-- Table structure for table `topics`
--

CREATE TABLE IF NOT EXISTS `topics` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `theory` text NOT NULL,
  PRIMARY KEY (`id`),
  KEY `id` (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=7 ;

--
-- Dumping data for table `topics`
--

INSERT INTO `topics` (`id`, `name`, `theory`) VALUES
(1, 'Чисельні методи', 'Для більшості задач необхідні знання теорем з Математичного аналізу та інших точних дисциплін.<br> Математичний аналіз дозволяє майже будь-який об''єкт математично описати. Саме завдяки математичним формулам, які описують певний об''єкт, можна запрограмувати цей об''єкт. Для цього записуються закони поводження об''єкта в різних умовах, його властивості, параметри та інше. Для цих формул та законів можуть справджуватись певні теореми. Знання цих теорем домоможе у вирішенні деяких проблем.<br>\r\nЯк приклад наведемо алгоритм Евкліда:<br>\r\nАлгоритм Евкліда - це ефективний спосіб знаходження найбільшого спільного дільника.<br>\r\nАлгоритм Евкліда заснований на тому, що НСД не змінюється, якщо від більшого числа відняти менше. Наприклад, 21 є НСД чисел 252 та 105 (252 = 21 * 12; 105 = 21 * 5); оскільки 252 - 105 = 147, НСД 147 та 105 також 21. Оскільки більше з двох чисел постійно зменшується, повторне виконання цього кроку дає все менші числа, поки одне з них не дорівнюватиме нулю. Коли одне з чисел дорівнюватиме нулю, те, що залишилось, і є НСД. <br>\r\nАлгоритм Евкліда має багато застосувань на практиці, та в теорії. З його допомогою можна згенерувати практично всі найважливіші музичні ритми різних культур у всьому світі. Алгоритм Евкліда відіграє ключову роль в поширеному методі криптографії з відкритим ключем. Його також використовують для пошуку розв''язків Діофантових рівнянь, наприклад, пошук чисел, що задовільняють декільком умовам або обернені числа в скінченному полі. Алгоритм Евкліда також застосовують для побудови ланцюгових дробів в методі Штурма для пошуку дійсних коренів полінома, та в сучасних методах факторизації цілих.<br>\r\nПсевдокод:<br>\r\nфункція нсд(a, b) <br>\r\nпоки b - 0 <br>\r\nt := b <br>\r\nb := a mod b <br>\r\na := t <br>\r\nповерни a <br>\r\nОтже, як бачимо, теорему, яку сформулював ще давньогрецький математик Евклід, широко використовують у програмуванні.<br>\r\nТаких прикладів можна навести ще дуже багато. А отже, можна зробити висновок, що чисельні методи відіграють важливу роль у програмуванні.'),
(2, 'Графи', 'Багато задач можна сформулювати в термінах графів, тобто у вигляді точок та зв’язків між ними. Тому ефективні алгоритми задач теорії графів мають велике практичне значення. \n<center><br><b>1. Поняття графа та його зображення в пам’яті комп’ютера</b></center>\n<br><b>Граф</b> — це сукупність непустої множини V вершин і множини E невпорядкованих та впорядкованих пар вершин: G = (V, E)V. Невпорядкована пара вершин називається <b>ребром</b>, впорядкована пара вершин — <b>дугою</b>. \n<p>Граф, який містить тільки ребра, називається <i>неорієнтованим</i>. Граф, що містить дуги, називається <i>орієнтованим</i> або <i>орграфом</i>. Вершини, котрі з’єднані ребром, називаються суміжними. </p>\n<br>Граф зображують на площині у вигляді множини точок, котрі відповідають вершинам, та лініями, котрі відповідають ребрам. \n<br><br>У процесі розробки програм, котрі використовують алгоритми на графах, потрібно вибрати спосіб зображення графа в оперативній пам’яті. \n<br>Для цього використовують <i>матриці суміжності, матриці інциденцій, масиви дуг, списки суміжності</i>. \n<br>Нехай n  — кількість вершин графа,  m — кількість його ребер. \n<br>Матриця Adj суміжності являє собою квадратну n x n матрицю, в якій \n<br><br><img src = "http://77.47.239.14/cursach/res/adj.png ">\n<br>Матриця інциденцій для неорієнтованого графа являє собою n  m матрицю, в якій\n<br><br><img src = "http://77.47.239.14/cursach/res/1.png ">\n<br>Матриця інциденцій для орграфа являє собою матрицю n x m, в якій\n<br><br><img src = "http://77.47.239.14/cursach/res/2.png ">\n<br><br>Граф, в якому кожному ребру (i, j) поставлено у відповідність число wij, називається <i>зважений</i>, а число wij називається <i>вагою ребра (i, j)</i>. Зважений граф можна зобразити <i>матрицею вагів</i>. \n<br>Вага неіснуючого ребра приймається рівною нескінченності ∞ або 0.\n<center><br><b>2. Найкоротші шляхи у графі</b></center>\n<br>Для будь-яких двох вершин vi, vj графа G може існувати декілька шляхів, котрі з’єднують їх. Розглянемо алгоритм, котрий визначає такий шлях від вершини vi до вершини  vj, що має мінімальну можливу довжину. \n<br>Нехай задано орієнтований граф G = (V, E) матрицею суміжності А.  Для будь-яких вершин vi, vj  ваги дуг невід’ємні. Задані початкова start та кінцева finish вершини графа, між яким потрібно знайти найкоротший шлях або шлях з мінімальною вагою. \n<br>Ваги дуг записано у матриці суміжності А. Якщо вершини  vi, vj  не зв’язані дугою, то значення елемента матриці суміжності задається як нескінченність, тобто A[i, j] = ∞. \n<br>Шлях між початковою та кінцевою вершинами визначається як найменша сума шляхів між цими вершинами.\n<br><br>Для розв’язання задачі розглянемо <i>алгоритм Дейкстри</i>, ідея котрого така. \n<br>Нехай відомо m вершин, довжина шляхів до котрих від вершини start найменша. Нехай відомі найкоротші шляхи, котрі з’єднують вершину start з m іншими вершинами. Відмітимо  вершину start та m найближчих до неї вершин. Для кожної невідміченої вершини побудуємо шляхи, що з’єднують її з останньою відміченою вершиною. Виберемо з цих шляхів найкоротший і відмітимо m+1 вершину. \n<br>Отже, найкоротший шлях від вершини start до m + 1 вершини при додатних значеннях ваг дуг має містити тільки відмічені вершини як проміжні. \n<br>Для формального опису алгоритму введемо такі позначення: weigth — матриця вагів дуг графа,  SignVertex — масив відмічених вершин, Path — масив найкоротших шляхів від вершини start до поточної, Vertex — масив номерів відмічених вершин, повз яких проходить найкоротший шлях, n — кількість вершин графа, start, finish — номери початкової та кінцевої вершини найкоротшого шляху.\n<br><br>1.Усі вершини та дуги графа не відмічені. Нехай Path[start] := 0, тобто довжина шляху від початкової вершини до неї самої дорівнює 0. <br>Довжина шляхів до усіх інших вершин Path[i] := ∞, де i ≠ start. Відмітити вершину start, і запам’ятати її номер, тобто\n<br> SignVertex[start]:=1; j:=start. \n<br>2.Для кожної невідміченої вершини i обчислити довжину шляху Path[i]:=min{Path[i],Path[j]+weigth[j,i]}.\n<br>3. Якщо Path[i]:= ∞ для усіх невідмічених вершин i, то закінчити розрахунки у зв’язку з відсутністю шляхів від вершини start до вершини finish. В протилежному випадку відмітити ту з вершин i, для котрої величина Path[i] є мінімальною та запам’ятати номер цієї вершини(j:=i; SignVertex[j]:=1).\n<br>4. Якщо відмічена кінцева вершина, тобто j=finish, то закінчити розрахунки: найкоротший шлях знайдено, він складається з відмічених вершин. В протилежному випадку повторити пункти 2 – 4.  \n<center><br><b>3. Обхід графа </b></center>\nВ основі багатьох алгоритмів на графах лежить систематичний перебір його вершин в результаті обходу графа. Найбільш поширені алгоритми обходу графа —  пошук у ширину та глибину.\n<center><br><i>3.1. Пошук у глибину </i></center>\n<br><i>Пошук у глибину</i> (від англ. depth first search) починається із заданої вершини графа. Пошук продовжується у глибину доки, поки є вершини, котрі утворюють маршрут пошуку. \n<br>Нехай пошук починається з вершини v. Для продовження пошуку вибирається ребро (v,u), інцидентне v. Якщо вершину u вже відвідували, то здійснюється пошук іншого ребра, інцидентного v. Якщо вершина u раніше не відвідувалася, то виконується перехід до неї і знову починається пошук вже з вершини u. Коли всі шляхи, що починаються з вершини u, вже пройдені, то повертаються до вершини v. Продовжується пошук ребер, інцидентних вершині v і таких, що не відвідувалися раніше. \n<br>Вибір нових ребер продовжується доти, доки не буде вичерпаний список цих ребер. \n<br>Якщо пошук здійснюється на зв’язаному неорієнтованому графі, то відвідується кожна вершина і перевіряється кожне ребро. Якщо граф орієнтований, то будучи у вершині v, вибираємо ребра (v,u), котрі виходять з v. \n<br>Перевіривши усі ребра, котрі виходять з u, повертаємося у вершину v навіть тоді, коли в u входять інші ребра, що не розглядалися. Якщо нема таких вершин, котрі суміжні з вершиною u і не розглядалися раніше, то повертаємося до попередньої вершини. Якщо це вершина, з якої починався пошук, то алгоритм завершує свою роботу. \n<br><br>Важлива властивість алгоритму <i>пошуку у глибину</i> [Кормен] полягає в тому, що терміни виявлення вершини v та закінчення обробки списку суміжних з v вершин утворюють правильну скобкову структуру. Якщо позначити виявлення вершини v дужкою, котра відкривається, а термін закінчення обробки суміжних з нею вершин дужкою, що закривається, то послідовність дій утворить правильно побудований вираз із дужок.  \n<br><br>Оцінка складності алгоритму складає O(n + m), де n — кількість вершин графа, m — кількість ребер графа. \n<br>Оцінка складності алгоритму визначається, виходячи з того, що пошук вершини, котра не була відвідувана, виконується за O(n) кроків, а кількість кроків для перевірки усіх ребер, інцидентних вершині, котра відвідується, складає O(m).   \n<center><br><i>3.2. Пошук у ширину</i></center>\n<br>Алгоритм <i>пошуку у ширину</i> (від англ. breadth first search) перераховує усі вершини, котрі досяжні від початкової до шуканої в порядку збільшення відстані від початкової вершини. Відстань розраховується як довжина найкоротшого шляху від початкової вершини до її сусідів. \n<br>Під час пошуку у ширину кожна вершина графа, котра відвідується, розміщується у <i>черзі</i>. Всі вершини, котрі не були відвідувані, але входять до списку суміжності, розміщуються у стеку. Вершина, що була відвідувана, вилучається з черги. \n<br>Процес продовжується доки, поки черга не стане пустою. \n<br><br>Оцінка складності алгоритму складає O(n + m), де n — кількість вершин графа, m — кількість ребер графа. \n<br>Оцінка складності алгоритму визначається, виходячи з того, що кожна вершина додається до черги і видаляється з неї один раз, а кількість ітерацій циклу пошуку наступних вершин відповідно списку суміжності має порядок кількості ребер графа.\n<center><br><b>4. Топологічне сортування</b></center>\n<br> Нехай є орієнтований ациклічний граф G(V, E), вершини котрого є елементами деякої множини, а дуги зображають відношення порядку. Помітимо вершини числами від 1 до |V|.  \n<br><br>Задача топологічного сортування[Вирт] цього графа полягає в тому, що потрібно вказати такий лінійний порядок на його вершинах, відповідно до котрого будь-яка дуга (i, j) направлена з вершини i у вершину j за умови  i < j. \n<br>Мета топологічного сортування графа — розмістити вершини графа на горизонтальній прямій так, щоб всі дуги прямували зліва направо. \n<br>Очевидно, що наявність циклів в графі заперечує існування лінійного порядку. \n<br><br><i>Топологічне сортування</i> починається з пошуку вершини графа,  котра <i>не має попередніх вершин</i>. Ця вершина розміщується на початку лінійного зв’язаного списку вершин і видаляється з графа. \n<br>Множина вершин графа, що залишилася, є частково упорядкованою. Тому процес пошуку вершини, котра не має попередників, продовжується доти, <i>доки множина вершин не стане пустою</i>. \n<br><br>Топологічне сортування виконується за O( |V| + |E| ) операцій, оскільки кожна дуга перевіряється один раз і для кожної вершини викликається один раз процедура топологічного сортування. \n<br><br><a href=''http://oim.asu.kpi.ua/files/DM/29_Graph_Search.pdf''>Дискретна математика. Лекція 29: “ Обхід графів“</a> О. І. Молчановський'),
(3, 'Рядки', 'Один з різновидів одновимірних масивів – <i>масив символів або рядок</i> – посідає особливе місце в багатьох мовах програмування. І це не випадково, адже алгоритми перетворення рядків застосовуються у вкрай широкому колі задач: редагуванні та перекладі текстів, алгебраїчних перетвореннях формул, криптоаналізі, інформаційно-пошукових системах, електронних словниках тощо. \n<br>Більш того, відомо, що будь-який алгоритм можна подати у вигляді алгоритму перетворення рядків. \n<br><br><b><center>1. Поняття рядку та оголошення змінних рядкового типу</b></center>\n<br><b>Рядок</b> — це скінченна послідовність символів, яку можна розглядати як особливу форму одновимірного масиву. Нагадаємо, що одна з характеристик масиву — це <i>кількість його елементів</i>, яка є фіксованою величиною і визначається під час оголошення масиву. Рядок, як масив символів, теж характеризується довжиною, тобто кількістю символів. Але для рядка розрізняють <i>поняття загальної та поточної довжини</i>. \n<br>Загальна довжина рядка визначається <i>об''ємом оперативної пам’яті</i>, що була надана рядку під час його оголошення. Поточна довжина рядка визначає кількість символів у рядку в конкретний момент виконання програми, вона ніколи не перевищує загальної довжини. \n<br>Спосіб визначення поточної довжини рядка залежить від способу оголошення відповідної рядкової змінної. \n<br><br>В мові C++ існує два способи оголошення змінної-рядка: \n<br>оголошення змінної спеціального структурованого типу даних string;\n<br>оголошення змінної типу символьного масиву.\n<br><br>В разі оголошення рядка як змінної типу string його поточна довжина зберігається в елементі з нульовим індексом. В цей елемент записується символ, код якого дорівнює значенню довжини. При виведенні рядка користувач не побачить цього символа, але у програмі можна прочитати або змінити його значення. При цьому слід не забувати, що <i>нульовий елемент рядка – це символ, а не число,</i>.\n<br><br>В разі оголошення рядка як змінної типу символьного масиву його поточна довжина  фіксується спеціальним символом, що розташований після останнього інформаційного символа рядка. Цей спеціальний символ називається <i>символом кінця рядка або нуль-символом (NULL-символом)</i>, його ASCII-код дорівнює 0 і позначається цей символ лексемою #0. \n<br>Зазначимо, що лише до тих рядків, які є змінними типу string, можуть бути застосовані бібліотечні функції обробки рядків, а також операції присвоєння, об''єднання та порівняння. Натомість, обробка символьних масивів є нічим не легшою від обробки одновимірних масивів у загальному випадку. Тому надалі розглядатимемо лише ті змінні-рядки, що оголошені як змінні типу string.\n<br><br>Зауважимо ще, що поточна довжина рядка визначається автоматично під час його ініціалізації. Зокрема, при введенні рядка з клавіатури, його довжина дорівнюватиме кількості введених до натиснення клавіші Enter символів. \n\n<br><br>Оскільки будь-який символ займає один байт пам''яті, то максимальне значення загальної довжини рядка буде обмежено максимальним значенням, яке можна записати у один байт. \n<br>Отже, максимальне значення довжини рядка становить 255 символів. Якщо під час оголошення рядкової змінної не вказана загальна довжина рядка, то за домовленістю вона вважається рівною 255. Обсяг пам’яті, що виділяється для збереження значення рядкової змінної, буде на один байт більшим від вказаної в оголошенні загальної довжини рядка за рахунок байта, в якому зберігається значення його поточної довжини. \n<br><br>Зображення рядкової змінної "+ Turbo Pascal" в оперативній пам’яті буде таким:\n<br><br><center><img src = "http://77.47.239.14/cursach/res/16.png "></center>\n<br><br><center><b>2. Операції над рядками та рядкові вирази</b></center>\n<br><br>В мові Паскаль змінні типу string можна обробляти двома способами. Перший спосіб дозволяє обробляти рядок як цілісний об’єкт. Другий спосіб розглядає рядок як об’єкт, що складається з окремих символів, тобто з елементів типу char. \n<br>Перший спосіб надає можливість за одну операцію присвоювати рядковій змінній значення рядка символів, виконувати об’єднання декількох рядків тощо. \n<br>Другий спосіб забезпечує доступ до окремих символів рядка за їх індексами аналогічно доступу до елементів одновимірного масиву. Для доступу до символа рядка застосовують операцію індексування: \n<br><br><ім’я змінної рядкового типу>[<індекс символа>]\n<br><br>Отже, розглянемо визначені мовою Паскаль операції над даними рядкового типу.\n<br><br><i><center>Присвоєння рядків</i></center>\n<br><br>Вираз рядкового типу можна присвоїти змінній рядкового типу. Символи рядка, що є значенням рядкового виразу, присвоюються відповідним елементам змінної. Якщо значення довжини рядкового виразу більше загальної довжини змінної, то присвоюються лише перші символи в межах означеної кількості. \n<br>Під час операції присвоєння неявно модифікується нульовий елемент змінної, що набуває нового значення. Наприклад, нехай змінна str означена як string[5]. \n<br>Після присвоєння str:=''Kiyv''значення символів рядка стануть такими: str[0]=chr(4), str[1]=''K'', str[2]=''i'', str[3]=''y'', str[4]=''v''. Якщо згодом виконати присвоєння str:=''Ukraine'', то символи ''ne'' в str будуть втрачені. \n<br><br><b><center>Операція об’єднання рядків (конкатенація) </b></center>\n<br>Над рядковими змінними означена операція <i>конкатенації</i>, що виконує дописування  одного рядка в кінець іншого. Ця операція позначена знаком арифметичної операції додавання ''+''. \n<br>Під час конкатенації рядків поточна довжина рядка, до якого приєднується інший рядок, збільшується на кількість символів, що додаються. Збільшення довжини об’єднаного рядка здійснюється тільки у заданих під час оголошення межах. \n<br><br><i><center>Порівняння рядків</i></center>\n<br><br> Кожному символу відповідає унікальний код в таблиці символів ASCII. З двох символів більшим вважається той, код якого більший. Рядки являють собою послідовності символів, і порівняння рядків виконується як серія порівнянь тих символів рядків, що мають однакові індекси. \n<br>Більш точно, рядки порівнюються відповідно до їх лексикографічного або алфавітного порядку. А саме, спочатку порівнюються перші символи рядків (символи з індексами 1). Якщо ці символи відмінні, то більшим вважається той рядок, перший символ котрого більший. В іншому разі порівнюються другі символи рядків. Якщо і другі символи рядків виявляються однаковими, то порівнюються треті символи рядків тощо. <br>Таким чином, якщо a і b – деякі рядки, а i – це такий найменший індекс, що a[i]≠b[i], то рядок a вважається більшим в тому разі, якщо a[i]>b[i] і навпаки. \n<br>Постає питання: а якщо такого індекса i, що a[i]≠b[i]не існує? \n<br><br>Тоді можливі два варіанти. \n<br><br><a href=''ftp://ftp.asu.kpi.ua/Kovaluk/BOOKS/OPAM%20by%20Kovalyuk\n%20(doc)/Chap_5_array+string/''>Рядки. Розділ 5 “Рядки”, ст. 17, “Рядки”</a> Т. В. Ковалюк'),
(4, 'Потоки', '<center><b>1. Мережі та потоки </center></b>\n<br><i>Мережу</i> можна представити як систему, яка транспортує деякий продукт з однієї точки в іншу. Цим продуктом можуть бути люди, електроенергія, природній газ, нафта та багато іншого. \n<br>Прикладом може бути система нафтопроводу, де нафта тече з однієї точки до інших точок систем. \n<br>Використовуючи таке представлення розглянемо мережу як орієнтований граф, де кожному ребру e = (v, u) відповідає додатне дійсне число c(e), яке називається <b>пропускною спроможністю ребра</b> e. \n<br>Якщо між вершинами немає ребра, то пропускна спроможність дорівнює нулю. Такий граф не може мати петель, адже розглядаються задачі для транспортування продукту тільки між різними вершинами. \n<br><br>Необхідна умова: орієнтований <i>граф повинен бути зв’язним</i>. \n<br><br>Розглянемо також особливу вершину s, яка називається <i>джерелом</i>, – степінь заходу в неї дорівнює 0 (d+(s) = 0), \n<br>а також вершину t, яка називається <i>стоком</i>, – степінь виходу з неї дорівнює також 0 (d–(t) = 0). \n<br><br><b>Означення 35.1. </b>\n<br><i>Мережа</i> – це орієнтований граф G = (V, E) разом з ваговою функцією c: E→R+ та виділеними вершинам s та t, такими що\n<br> d+(s) = 0 та d–(t) = 0. \n<br>Мережу зручно представляти за допомогою матриці пропускних спроможностей C = ||cij||, де елемент матриці cij = c(vi, vj) дорівнює пропускній спроможності ребра (vi, vj), якщо воно існує, та cij = 0, якщо вершини vi та vj несуміжні. \n<br><br>Для кожного ребра e розглянемо значення функції f(e), яке визначає <i>потік через це ребро</i>. \nЗрозуміло, що величина потоку в ребрі не може перебільшувати пропускну спроможність цього ребра. Також будемо вимагати, щоб потік, який заходить у вершину дорівнював потоку, який виходить з вершини (окрім джерела s та стоку t). \n<br><br><b>Означення 35.2.</b>\n<br> Функція f: E→R+ називається <i>потоком</i> в мережі G, якщо: \n<br><br>1. Для кожного ребра (u, v)∈E виконується 0 ≤ f(u,v) ≤ c(u,v), тобто потік через ребро не є від’ємними та не перебільшує пропускну спроможність ребра. \n<br>2. Потік, який заходить у вершину дорівнює потоку, який виходить з вершини (окрім джерела s та стоку t). Друга умова називається умовою збереження потоку. \n<center><br><img src = "http://77.47.239.14/cursach/res/7.png "></center>\n<br><br>На Pис. 1 наведено приклад мережі з потоком. Ребра позначені парами чисел, де перше число – пропускна спроможність ребра, а друге – потік через дане ребро. Величина потоку становить 4 + 2 = 6. \n<br>Як можна пересвідчитись, розмір потоку, який потрапляє у стік t, дорівнює також 6 = 3 + 2 + 1. \n<center><br><br><b>2. Максимальні потоки </b></center>\n<br><br>Розглянемо способи визначення максимального потоку в мережі. \n<br>На Рис. 2, а зображено мережу, а на Pис. 2, б вказано максимальний потік в цій мережі. Зазначимо, що максимальний потік не обов’язково повинен бути єдиними. \n<br>В даному випадку відомо, що потік максимальний, тому що величина потоку, який виходить з джерела s, не може бути більшим за суму пропускних спроможностей ребер, які виходять з s. \n<br>Слід звернути увагу, що якщо потік з джерела дорівнює сумі пропускних спроможностей ребер, які виходять з джерела, або потік, якій втікає в стік, дорівнює пропускній спроможності ребер, які входять в стік, то потік є максимальним. \n<br>Однак, потік може бути максимальним й без виконання будь-якої з цих ознак.\n<center><br><img src = "http://77.47.239.14/cursach/res/8.png "></center>\n<center><br><br><b>3. Алгоритм Форда-Фалкерсона </b></center>\n<br><br>Тепер перейдемо до систематичного алгоритму для знаходження максимального потоку. \n<br>Кожній вершині поставимо у відповідність впорядковану пару. Перший елемент пари – <i>попередня вершина у ланцюгу</i>, що розглядається, потрібна для того щоб визначити зворотній шлях. Другий елемент пари – <i>резерв</i>, тобто величина, на яку можна збільшити потік в кожному ребрі уздовж шляху, якщо орієнтація ребра співпадає з напрямом мережі (таку орієнтацію назвемо правильною), або зменшити потік, якщо ребро орієнтовано неправильно. \n<br><br>Простіше кажучи, <i>резерв заданої вершини дорівнює максимальній величині, на яку потік уздовж ланцюга до цієї вершини можна збільшити без порушення самого потоку</i>. \n<br><br>Розглянемо також множину M, яка містить всі вершини, які не задіяні при побудові ланцюга до t. Якщо M виявиться порожньою до того, як буде досягнута t, то більше немає вершин, які можна перевірити на шляху до t, тому й немає іншого шляху в t, і немає більше можливості збільшити потік, – отже <i>потік максимальний</i>.\n<center><br><br><i>Алгоритм Форда-Фалкерсона знаходження максимального потоку</i></center>\n <br><br>1. Встановити попередника кожної вершини та резерв невизначеними. Вершина помічена, якщо її резерв не є невизначеним. Встановити резерв вершини s рівним ∞, для того щоб вона не обмежувала резерв інших вершин. Встановити М = {s}. \n<br>2. Якщо M порожня, то потік максимізований. Якщо M не є порожньою, то обрати довільний елемент з M та видаляємо його. \n<br>Нехай цей елемент v. \n<br>3. Якщо вершина w не помічена, (v, w) є ребром та f(v, w) < c(v, w), то встановити резерв вершини w рівним мінімуму величини c(v, w) – f(v, w) та резерву вершини v. \n<br>Встановити попередника вершини w в v. Якщо w ≠ t, то додати w в M. \n<br>4. Якщо вершина w не помічена, (w, v) є ребром та f(v, w) > 0, то встановити резерв вершини w рівним мінімуму величини f(v, w) та резерву вершини v. \n<br>Встановити попередника вершини w в v та додати w в M. \n<br>5. Якщо t помічена, то використовуючи попередні вершини повернутись до вершини s та для кожного ребра ланцюга додати резерв вершини t до потоку кожного правильно орієнтованого ребра, і відняти резерв t з потоку кожного неправильно орієнтованого ребра. \nПовернутись до кроку 1. \n<br>6. Повернутись до кроку 2. \n\n<br><br><a href=''http ://oim.asu.kpi.ua/files/DM/35_Networks_and_flows.pdf''>Конспект лекцій з дискретної математики, розділ Теорія Графів, тема “Мережі та\nпотоки”</a> О. І. Молчановський'),
(5, 'Бектрекінг, рекурсія', 'Опишемо загальний метод, який дає змогу значно зменшити обсяг обчислювань в алгоритмах типу повного перебору всіх можливостей пошуку мінімального шляху у деревах. \r\n<br><br>Щоб застосувати цей метод, розв’язок задачі повинен мати вигляд скінченої послідовності (x1, …, xn). \r\n<br>Головна ідея методу полягає в тому, що розв’язок будують поступово, починаючи з порожньої послідовності ∅ (довжиною 0). Загалом, якщо є частковий (неповний) розв’язок (x1, …, xi), де i<n, то намагаємося знайти таке допустиме значення xi+1, що можна продовжувати (x1, …, xi, xi+1) до отримання повного розв’язку. \r\n<br>Якщо таке допустиме, але ще не використане значення xi+1 існує, то долучаємо цю нову компоненту до часткового розв’язку і продовжуємо процес для послідовності (x1, …, xi, xi+1). Якщо такого значення xi+1 немає, то повертаємося до попередньої послідовності (x1, …, xi–1) і продовжуємо процес, шукаючи нове, ще не використане значення xi′. \r\n<br><br>Тому цей процес називають <i>бектрекінг</i> (англ. backtracking – пошук із поверненнями). Роботу цього алгоритму можна інтерпретувати як <i>процес обходу деякого дерева</i>. Кожна його вершина відповідає деякій послідовності (x1, …, xi), причому вершини, які відповідають послідовностям вигляду (x1, …, xi, y), − сини цієї вершини. Корінь дерева відповідає порожній послідовності. \r\n<br>Виконується обхід цього дерева <i>пошуком углиб</i>. Окрім того, задають предикат P, означений на всіх вершинах дерева. Якщо P(v) = False, то вершини піддерева з коренем у вершині v не розглядають, і обсяг перебору зменшується. Предикат P(v) набуває значення False тоді, коли стає зрозумілим, що послідовність (x1, …, xi), яка відповідає вершині v, ніяким способом не можна добудувати до повного розв’язку. \r\n<br>Проілюструємо застосування алгоритму <i>бектрекінгу</i> на конкретних прикладах. \r\n<br><br>Задано множину натуральних чисел {x1, …, xn}. Потрібно знайти її підмножину, сума елементів якої дорівнює заданому числу M.  \r\n<br><br>Починаємо з порожньої множини. Збільшуємо суму, послідовно добираючи доданки. Число з послідовності x1, …, xn долучають до суми, якщо сума після додавання цього числа не перевищує M. Якщо сума настільки велика, що додавання будь-якого нового числа перевищує M, то повертаємось і змінюємо останній доданок у сумі. \r\n<br>На Рис.1 проілюстровано алгоритм <i>бектрекінгу</i> для задачі пошуку підмножини множини {31, 27, 15, 11, 7, 5} із сумою 39. \r\n<center><br><br><image src = "http://77.47.239.14/cursach/res/5.png ">                </center>\r\n<br><br>Маємо наступний приклад. Як n ферзів можна розмістити на шахівниці n×n так, щоб жодні два ферзі не били один одного? \r\n\r\n<br><br>Для розв’язання цієї задачі потрібно визначити n позицій на шахівниці так, щоб жодні дві позиції не були в одному рядку, в одному стовпці та на одній діагоналі. \r\n<br>Діагональ містить усі позиції з координатами (i, j) такі, що i + j = m для довільних m, або i – j = m (тут i – номер рядка, j – номер стовпця). <br>1. Починаємо з порожньої шахівниці. На (k + 1)-му кроці намагаємося розмістити нового ферзя в (k + 1)-му стовпці, причому на перших k стовпцях вже є ферзі. \r\n<br>2. Перевіряємо клітинки в (k + 1)-му стовпці, починаючи з верхньої. \r\n<br>3. Шукаємо таку позицію для ферзя, щоб він не був у рядку та на діагоналі з тими ферзями, які вже є на шахівниці. Якщо це неможливо, то повертаємося до місця ферзя на попередньому k-му кроці та розміщаємо цього ферзя на наступному можливому рядку в цьому k-му стовпці, якщо такий порядок є, а ні, то повертаємося до ферзя в (k – 1)-му стовпці. \r\n<br><br>Алгоритм бектрекінгу для n = 4 наведений на Рис.2. \r\n<br>Кожній вершині дерева на Рис.2 відповідає послідовність довжиною від 0 до 4. Її kй член дорівнює номеру клітинки з ферзем у k-му стовпці. <br>Наприклад, вершинам шляху, який веде до розв’язку, відповідають такі послідовності: \r\n<br>∅, (2), (2, 4), (2, 4, 1), (2, 4, 1, 3).\r\n<center><br><br><image src = "http://77.47.239.14/cursach/res/6.png ">                </center>\r\n');
INSERT INTO `topics` (`id`, `name`, `theory`) VALUES
(6, 'Дерева', '<center><b>1. Основні означення та властивості</center></b> \r\n<br><br>Поняття дерева широко застосовують у багатьох розділах математики й інформатики. Наприклад, дерева використовують як інструмент обчислень, зручний спосіб збереження даних, їх сортування чи пошуку. \r\n<br><br><b>Означення 27.1.</b>\r\n<br> <i>Деревом називають зв’язний граф без простих циклів.</i> Граф, який не містить простих циклів і складається з k компонент зв’язності, називають <i>лісом</i> з k дерев. \r\n<br>З означення випливає, що дерева й ліси являють собою <i>прості графи</i>. \r\n<br>На Рис. 1 зображені приклади дерев.\r\n<center><br><br><img src = "http://77.47.239.14/cursach/res/9.png "></center>\r\n<br>У багатьох застосуваннях певну вершину дерева означають як корінь. Тоді можна природно приписати напрямок кожному ребру. Оскільки існує єдиний простий маршрут від кореня до кожної вершини графу, то можна орієнтувати кожне ребро в напрямку від кореня. \r\n<br>Отже, дерево разом із виділеним коренем утворює орієнтований граф, який називають <i>кореневим деревом</i>.  \r\n<br>Різні способи вибору кореня дають змогу утворити різні кореневі дерева. \r\n<br>Наприклад, на рис. 2, а зображено дерево, а на рис 2, б, в – кореневі дерева з коренями відповідно у вершинах a та c.   \r\n<center><br><br><img src = "http://77.47.239.14/cursach/res/10.png "></center> \r\n<br><br><b>Означення 27.2.</b>\r\n<br> Нехай G – кореневе дерево. Якщо v – його вершина, відмінна від кореня, то її батьком називають єдину вершину u таку, що є орієнтоване ребро (u, v). Якщо u – батько, то v – син. Аналогічно за генеалогічною термінологією можна означити інших пращурів і нащадків вершини v. Вершини дерева, які не мають синів, називаються <i>листками</i>. Вершини, які мають синів, називаються <i>внутрішніми</i>.\r\n <br>Дерево називають <i>повним m-арним</i>, якщо <i>кожна його внутрішня вершина має точно m синів</i>. \r\n<br>У разі m=2 дерево називають бінарним. \r\n<br><br><b>Означення 27.4.</b>\r\n<br> Кореневе дерево, у якому сини кожної внутрішньої вершини впорядковано, називають <i>упорядкованим</i>.  Таке дерево зображають так, щоб <i>сини кожної вершини були розміщені зліва направо</i>. \r\n<br>Якщо внутрішня вершина впорядкованого бінарного дерева має двох синів, то першого називають лівим, а другого – правим. \r\n<br><br><b>Теорема 27.2.</b>\r\n<br> Повне m-арне дерево з r внутрішніми вершинами містить n = mr + 1 вершин. \r\n<br><br><b>Означення 27.5.</b>\r\n<br> <i>Рівнем вершини v</i> в кореневому дереві називають довжину простого шляху від кореня до цієї вершини (цей шлях, очевидно, єдиний). \r\n<br>Рівень кореня вважають нульовим. \r\n<br><I>Висотою кореневого дерева</i> називають максимальний із рівнів його вершин. Інакше кажучи, висота кореневого дерева – це довжина найдовшого простого шляху від кореня до будь-якої вершини. \r\n<br>Повне m-арне дерево, у якого всі листки на одному рівні, називають <i>завершеним</i>. \r\n<br>Кореневе m-арне дерево з висотою h називають <i>збалансованим</i>, якщо всі його листки на рівнях h або h–1. \r\n<br><br><b>Теорема 27.3.</b>\r\n<br> Нехай m-арне дерево має висоту h. Тоді в ньому не більше ніж mh листків. \r\n<center><br><br><b>2. Обхід дерев </b></center>\r\n<br><br>Чимало задач можна моделювати з використанням кореневих дерев. \r\n<br>Поширене таке загальне формулювання задачі: виконати задану операцію D з кожною вершиною дерева. Тут D – параметр загальнішої задачі відвідування всіх вершин, або так званого обходу дерева. Розглядаючи розв’язання цієї задачі як єдиний послідовний процес відвідування вершин дерева в певному порядку, можна вважати їх розміщеними одна за одною. \r\n<br>Опис багатьох алгоритмів істотно спрощується, якщо можна говорити про наступну вершину дерева, маючи на увазі <i>якесь упорядкування</i>. Є три принципи впорядкування вершин, які природно випливають зі структури дерева. Як і саму деревоподібну структуру, їх зручно формулювати за допомогою рекурсії. \r\n<br>Звертаючись до бінарного дерева, де R – корінь, A та B – ліве та праве піддерева (рис. 3), можна означити такі впорядкування. \r\n<center><br><br><img src = "http://77.47.239.14/cursach/res/11.png "></center>          \r\n<br><br>1. Обхід у прямому порядку (preorder), або згори донизу: R, A, B (корінь відвідують до обходу піддерев). Для дерева з рис.3 послідовність вершин буде така: \r\na, b, d, e, h, k, c, f, g, m, n. \r\n<br>2. Обхід у внутрішньому порядку (inorder), або зліва направо: A, R, B. Для дерева з рис. 3 послідовність: d, b, h, e, k, a, f, c, m, g, n. \r\n<br>3. Обхід у зворотному порядку (postorder), або знизу догори: A, B, R (корінь відвідують після обходу піддерев). Для дерева з рис. 3 послідовність:d, h, k, e, b, f, m, n, g, c, a. \r\n<br><br>Зазначені способи обходу бінарних дерев можна узагальнити й на довільні m-арні дерева. Обхід таких дерев у прямому порядку (згори донизу) схематично зображено на рис. 4, а; у внутрішньому порядку (зліва направо) – на рис. 4, б; у зворотному (знизу вгору) – на рис. 4, в. \r\n<center><br><br><img src = "http://77.47.239.14/cursach/res/12.png "></center>  \r\n<center><b><br><br>3. Приклад застосування дерев </center></b>\r\n<br>Надзвичайно поширене в інформатиці застосування обходу дерев – зіставлення виразам (арифметичним, логічним тощо) дерев і побудова на цій основі різних форм запису виразів. \r\n<br>Суть справи зручно пояснити на прикладі. \r\n<br>Розглянемо арифметичний вираз: ( ) efd c b a −× × + . Подамо його у вигляді дерева (рис. 5). Внутрішнім  вершинам цього дерева відповідають символи операцій, а листкам – операнди. \r\n<br><br>T1 T2 Tm … \r\n<br>Крок (m+1): відвідати R \r\n<br>Крок 1: відвідати T1 знизу вгору \r\n<br>Крок 2: відвідати T2 знизу вгору \r\n<br>Крок m: відвідати Tm знизу вгору \r\n<br>R \r\n<br><br>T1 T2 Tm … \r\n<br><br>Крок 2: відвідати R \r\n<br>Крок 1: відвідати T1 згори донизу \r\n<br>Крок 3: відвідати T2 згори донизу \r\n<br>Крок (m+1): відвідати Tm згори донизу \r\n<br>R \r\n<br><br>T1 T2 Tm … \r\n<br><br>Крок 1: відвідати R \r\n<br>Крок 2: відвідати T1 згори донизу \r\n<br>Крок 3: відвідати T2 згори донизу \r\n<br>Крок (m+1): відвідати Tm згори донизу \r\n<br>R \r\n<center><br><br><img src = "http://77.47.239.14/cursach/res/13.png "></center>\r\n<br><br>Обійдемо це дерево, записуючи символи у вершинах у тому порядку, у якому вони зустрічаються в разі заданого способу обходу. Отримаємо такі три послідовності: \r\n<br><br>• у разі обходу в прямому порядку – префіксний (польський) запис defabc ×−+× / ; \r\n<br>• у разі обходу у внутрішньому порядку – інфіксний запис (поки що без дужок, які потрібні для визначення порядку операцій) efcdab ×−×+ / ; \r\n<br>• у разі обходу в зворотному порядку – постфіксний (зворотний польський) запис ×−×+ abcdef /. \r\n<br><br>Звернемося спочатку до інфіксної форми запису виразу. Без дужок вона неоднозначна: один запис може відповідати різним деревам. Щоб уникнути неоднозначності інфіксної форми, використовують круглі дужки щоразу, коли зустрічають операцію. Повністю «одужкований» вираз, одержаний під час обходу дерева у внутрішньому порядку, називають <i>інфіксною формою запису</i>. \r\n<br>Отже, для дерева з рис. 5 інфіксна форма така: ()))(( / ))(( efcdab ×−×+ . \r\n<br>Наведені міркування свідчать, що інфіксна форма запису виразів незручна. На практиці використовують префіксну та постфіксну форми, бо вони однозначно відповідають виразу й не потребують дужок. \r\n<br>Ці форми запису називаються <i>польським записом</i> (на честь польського математика Яна Лукасевича). \r\n<br>Для обчислення значення виразу в польському записі його проглядають справа наліво та знаходять два операнди разом зі знаком операції перед ними. Ці операнди та знак операції вилучають із запису, виконують операцію, а її результат записують на місце вилучення символів. \r\n<br><br>Для прикладу, обчислимо значення виразу в польському записі (^ - означає піднесення до степеня):\r\n<br> «+ × − 4 2 5 ^ 2 / 9 3». \r\n<br>За сформульованим правилом виділимо «/ 9 3», ці символи вилучимо й обчислимо 9 / 3 = 3; результат запишемо на місце вилучення символів «+ × − 4 2 5 ^ 2 3». \r\n<br>Продовжимо обчислення. \r\n<br><br>Для обчислення значення виразу в зворотному польському записі його переглядають зліва направо та виділяють два операнди разом зі знаком операції після них. Ці операнди та знак операції вилучають, а її результат записують на місце вилучених символів. \r\n<br>Оскільки польські записи однозначні та їх значення можна легко обчислити без сканування назад і вперед, їх <i>широко використовують у комп’ютерних науках</i>, особливо для конструювання компіляторів. \r\n<br><br>Наприклад, розглянемо можливий спосіб компіляції булевої функції (представлення функції у польському записі та обчислення значень функції залежно від значень операндів): (¬x ∧ (y ~ ¬x)) ∨ ¬y. \r\n<br>Подамо його у вигляді дерева (рис. 6).\r\n<center><br><br><img src = "http://77.47.239.14/cursach/res/14.png "></center>\r\n<br><br>Згідно з прямим та зворотним порядками обходу дерева отримаємо відповідно пряму та зворотну польські форми записів: \r\n<br>«∨ ∧ ¬ x ~ y  ¬x ¬y» та «x ¬ y x ¬ ~ ∧ y ¬ ∨».  \r\n<br>Відмітимо один факт, який стосується булевих виразів. Як відомо, в булевій алгебрі є одна унарна операція – заперечення «¬». Тож ми не можемо сліпо виконувати правила, зазначені раніше, про заміну двох операндів та операції, яка йде перед чи після операндів, на результат операції. Потрібно ввести обмеження на використання цих правил, зазначивши, що вони виконуються тільки для бінарних операцій. \r\n<br><br>Для унарних же операцій (заперечення «¬») правила мають вигляд: замінювати операнд та операцію заперечення «¬», яка стоїть перед операндом, на результат операції (для прямої польської форми) та замінювати операнд та операцію заперечення «¬», яка стоїть після операнда, на результат операції (для оберненої польської форми).  \r\n<br><br>Отже, для прямої польської форми отримаємо таке загальне правило обчислення результату булевих виразів. \r\n<br><br>Переглядаємо послідовність справа наліво та виділяємо один операнд та операцію заперечення «¬», яка стоїть перед цим операндом, або два операнди та операцію, відмінну від заперечення та яка стоїть перед цими операндами. Вибрані операнд(и) та операцію замінюємо в послідовності на результат застосування операції до операнда(ів). \r\n<br>Аналогічно формулюється правило обчислення результату булевих виразів у зворотній польській формі. Обчислимо значення функції на наборі (1, 0), використовуючи прямий польський запис. Для цього замість символів x та y підставляємо 1 та 0 відповідно й застосовуємо вказане правило доки не отримаємо кінцевий результат (табл. 2). \r\n<br>Проведемо аналогічні обчислення на наборі (0, 0), але використовуючи вже зворотній польській запис (табл. 3). \r\n<center><br><br><img src = "http://77.47.239.14/cursach/res/15.png "></center>\r\n\r\n');

-- --------------------------------------------------------

--
-- Table structure for table `visitors`
--

CREATE TABLE IF NOT EXISTS `visitors` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `ip` varchar(20) NOT NULL,
  `time` varchar(50) NOT NULL,
  `location` text NOT NULL,
  PRIMARY KEY (`id`),
  KEY `id` (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=58 ;

--
-- Dumping data for table `visitors`
--

INSERT INTO `visitors` (`id`, `ip`, `time`, `location`) VALUES
(1, '94.179.75.3', '01.06.15 22:41:50', '/rgr/index.php'),
(2, '94.179.75.3', '01.06.15 22:41:54', '/rgr/theory/index.php'),
(3, '94.179.75.3', '01.06.15 22:41:57', '/rgr/theory/index.php?t=1'),
(4, '94.179.75.3', '01.06.15 22:42:02', '/rgr/cource/index.php'),
(5, '94.179.75.3', '01.06.15 22:42:03', '/rgr/cource/index.php?t=1'),
(6, '94.179.75.3', '01.06.15 22:42:59', '/rgr/contacts/index.php'),
(7, '94.179.75.3', '01.06.15 22:43:00', '/rgr/index.php'),
(8, '212.80.32.20', '01.06.15 23:06:58', '/rgr/index.php'),
(9, '212.80.32.20', '01.06.15 23:07:05', '/rgr/index.php'),
(10, '212.80.32.20', '01.06.15 23:08:54', '/rgr/index.php'),
(11, '212.80.32.20', '01.06.15 23:09:20', '/rgr/index.php'),
(12, '212.80.32.20', '01.06.15 23:09:22', '/rgr/index.php'),
(13, '212.80.32.20', '01.06.15 23:09:26', '/rgr/index.php'),
(14, '212.80.32.20', '01.06.15 23:12:03', '/rgr/index.php'),
(15, '212.80.32.20', '01.06.15 23:13:50', '/rgr/index.php'),
(16, '212.80.32.20', '01.06.15 23:13:52', '/rgr/index.php'),
(17, '212.80.32.20', '01.06.15 23:14:23', '/rgr/index.php'),
(18, '212.80.32.20', '01.06.15 23:14:26', '/rgr/index.php'),
(19, '212.80.32.20', '01.06.15 23:14:33', '/rgr/index.php'),
(20, '94.179.50.108', '01.06.15 23:18:00', '/rgr/cource/index.php'),
(21, '94.179.50.108', '01.06.15 23:18:01', '/rgr/cource/index.php?t=1'),
(22, '94.179.50.108', '01.06.15 23:18:05', '/rgr/cource/index.php?t=2'),
(23, '94.179.50.108', '01.06.15 23:18:10', '/rgr/index.php'),
(24, '94.179.50.108', '01.06.15 23:28:36', '/rgr/theory/index.php'),
(25, '94.179.50.108', '01.06.15 23:28:38', '/rgr/theory/index.php?t=1'),
(26, '94.179.50.108', '01.06.15 23:28:40', '/rgr/cource/index.php'),
(27, '94.179.50.108', '01.06.15 23:28:41', '/rgr/cource/index.php?t=5'),
(28, '212.80.32.20', '01.06.15 23:32:41', '/rgr/theory/index.php'),
(29, '212.80.32.20', '01.06.15 23:32:42', '/rgr/theory/index.php?t=1'),
(30, '212.80.32.20', '01.06.15 23:32:45', '/rgr/theory/index.php'),
(31, '212.80.32.20', '01.06.15 23:32:46', '/rgr/cource/index.php'),
(32, '212.80.32.20', '01.06.15 23:32:47', '/rgr/cource/index.php?t=1'),
(33, '212.80.32.20', '01.06.15 23:32:50', '/rgr/tasks/index.php'),
(34, '212.80.32.20', '01.06.15 23:32:51', '/rgr/tasks/index.php?t=6&sort=diff'),
(35, '212.80.32.20', '02.06.15 00:12:32', '/rgr/index.php'),
(36, '212.80.32.20', '02.06.15 00:12:38', '/rgr/index.php'),
(37, '212.80.32.20', '02.06.15 00:12:49', '/rgr/index.php'),
(38, '212.80.32.20', '02.06.15 00:14:34', '/rgr/index.php'),
(39, '212.80.32.20', '02.06.15 00:14:40', '/rgr/index.php'),
(40, '212.80.32.20', '02.06.15 00:17:14', '/rgr/index.php'),
(41, '87.240.182.142', '02.06.15 00:18:14', '/rgr/index.php'),
(42, '212.80.32.20', '02.06.15 00:18:20', '/rgr/index.php'),
(43, '46.211.133.234', '02.06.15 00:26:59', '/rgr/index.php'),
(44, '77.47.132.64', '02.06.15 09:19:40', '/rgr/index.php'),
(45, '77.47.132.64', '02.06.15 09:20:04', '/rgr/index.php'),
(46, '66.249.81.234', '02.06.15 09:29:19', '/rgr/index.php'),
(47, '77.47.194.254', '02.06.15 12:31:59', '/rgr/index.php'),
(48, '77.47.194.254', '02.06.15 12:32:01', '/rgr/theory/index.php'),
(49, '77.47.194.254', '02.06.15 12:32:03', '/rgr/theory/index.php?t=4'),
(50, '77.47.194.254', '02.06.15 12:32:05', '/rgr/contacts/index.php'),
(51, '77.47.194.254', '02.06.15 12:32:06', '/rgr/cource/index.php'),
(52, '77.47.194.254', '02.06.15 12:32:07', '/rgr/contacts/index.php'),
(53, '77.47.194.254', '02.06.15 13:16:53', '/rgr/index.php'),
(54, '77.47.194.254', '02.06.15 13:17:49', '/rgr/cource/index.php'),
(55, '77.47.194.254', '02.06.15 13:17:51', '/rgr/cource/index.php?t=1'),
(56, '77.47.194.254', '02.06.15 13:20:04', '/rgr/cource/index.php'),
(57, '77.47.194.254', '02.06.15 13:20:05', '/rgr/cource/index.php?t=2');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
